# Indices settings
Indices:
  - index_name: cohorts
    type: neo4j
    mapping:
      id:
        type: keyword
      participant_id:
        type: keyword
        normalizer: lowercase
      race:
        type: keyword
      sex_at_birth:
        type: keyword
      dbgap_accession:
        type: keyword
      study_status:
        type: keyword
      diagnosis_str:
        type: keyword
      # Diagnosis records
      diagnoses:
        type: nested
        properties:
          id:
            type: keyword
          diagnosis_id:
            type: keyword
          age_at_diagnosis:
            type: integer
          anatomic_site:
            type: keyword
          diagnosis:
            type: keyword
          diagnosis_basis:
            type: keyword
          diagnosis_category:
            type: keyword
          diagnosis_classification_system:
            type: keyword
          diagnosis_comment:
            type: keyword
          disease_phase:
            type: keyword
          toronto_childhood_cancer_staging:
            type: keyword
          tumor_classification:
            type: keyword
          tumor_grade:
            type: keyword
          tumor_stage_clinical_m:
            type: keyword
          tumor_stage_clinical_n:
            type: keyword
          tumor_stage_clinical_t:
            type: keyword
      # Survival records
      survivals:
        type: nested
        properties:
          id:
            type: keyword
          survival_id:
            type: keyword
          age_at_event_free_survival_status:
            type: integer
          age_at_last_known_survival_status:
            type: integer
          cause_of_death:
            type: keyword
          event_free_survival_status:
            type: keyword
          first_event:
            type: keyword
          last_known_survival_status:
            type: keyword
      # Treatment records
      treatments:
        type: nested
        properties:
          id:
            type: keyword
          treatment_id:
            type: keyword
          age_at_treatment_end:
            type: integer
          age_at_treatment_start:
            type: integer
          treatment_agent: # list
            type: keyword
          treatment_type:
            type: keyword
      # Treatment Response records
      treatment_responses:
        type: nested
        properties:
          id:
            type: keyword
          treatment_response_id:
            type: keyword
          age_at_response:
            type: integer
          response:
            type: keyword
          response_category:
            type: keyword
          response_system:
            type: keyword
      samples:
        type: nested
        properties:
          id:
            type: keyword
          sample_id:
            type: keyword
          anatomic_site:
            type: keyword
          participant_age_at_collection:
            type: integer
          sample_tumor_status:
            type: keyword
          tumor_classification:
            type: keyword
          sample_description:
            type: keyword
      files:
        type: nested
        properties:
          id:
            type: keyword
          file_id:
            type: keyword
          file_name:
            type: keyword
          data_category:
            type: keyword
          file_type:
            type: keyword
          file_description:
            type: keyword
          file_size:
            type: keyword
          md5sum:
            type: keyword
          file_access:
            type: keyword
          dcf_indexd_guid:
            type: keyword
          library_selection:
            type: keyword
          library_strategy:
            type: keyword
          library_source_material:
            type: keyword
          library_source_molecule:
            type: keyword
    cypher_queries:
      - query: |
          MATCH (p:participant)-[:of_participant]->(cg:consent_group)-[:of_consent_group]->(stu:study)
          WITH p, stu
          SKIP $skip LIMIT $limit
          OPTIONAL MATCH (d:diagnosis)-[*..4]->(p)
          OPTIONAL MATCH (sur:survival)-[:of_survival]->(p)
          OPTIONAL MATCH (t:treatment)-[:of_treatment]->(p)
          OPTIONAL MATCH (tresp:treatment_response)-[:of_treatment_response]->(p)
          OPTIONAL MATCH (s:sample)-[*..4]->(p)
          OPTIONAL MATCH (file)-[*..4]->(p)
          where (file: clinical_measure_file or file: generic_file or file: radiology_file or file: sequencing_file or file: methylation_array_file or file: pathology_file or file: cytogenomic_file)
          RETURN
            p.id AS id,
            p.participant_id AS participant_id,
            p.race AS race,
            p.sex_at_birth AS sex_at_birth,
            stu.dbgap_accession AS dbgap_accession,
            stu.study_status AS study_status,
            apoc.text.join(COLLECT(distinct d.diagnosis), ';') AS diagnosis_str,
            (CASE
              WHEN COUNT(DISTINCT d) > 0 THEN COLLECT(DISTINCT {
                id: d.id,
                diagnosis_id: d.diagnosis_id,
                age_at_diagnosis: d.age_at_diagnosis,
                anatomic_site: d.anatomic_site,
                diagnosis: d.diagnosis,
                diagnosis_basis: d.diagnosis_basis,
                diagnosis_classification_system: d.diagnosis_classification_system,
                diagnosis_comment: d.diagnosis_comment,
                disease_phase: d.disease_phase,
                toronto_childhood_cancer_staging: d.toronto_childhood_cancer_staging,
                tumor_classification: d.tumor_classification,
                diagnosis_category: d.diagnosis_category,
                tumor_grade: d.tumor_grade,
                tumor_stage_clinical_m: d.tumor_stage_clinical_m,
                tumor_stage_clinical_n: d.tumor_stage_clinical_n,
                tumor_stage_clinical_t: d.tumor_stage_clinical_t
              })
              ELSE []
            END) AS diagnoses,
            (CASE
              WHEN COUNT(DISTINCT sur) > 0 THEN COLLECT(DISTINCT {
                id: sur.id,
                survival_id: sur.survival_id,
                age_at_event_free_survival_status: sur.age_at_event_free_survival_status,
                age_at_last_known_survival_status: sur.age_at_last_known_survival_status,
                cause_of_death: sur.cause_of_death,
                event_free_survival_status: sur.event_free_survival_status,
                first_event: sur.first_event,
                last_known_survival_status: sur.last_known_survival_status
              })
              ELSE []
            END) AS survivals,
            (CASE
              WHEN COUNT(DISTINCT t) > 0 THEN COLLECT(DISTINCT {
                id: t.id,
                treatment_id: t.treatment_id,
                age_at_treatment_end: t.age_at_treatment_end,
                age_at_treatment_start: t.age_at_treatment_start,
                treatment_agent: apoc.text.split(t.treatment_agent, ';'),
                treatment_type: t.treatment_type
              })
              ELSE []
            END) AS treatments,
            (CASE
              WHEN COUNT(DISTINCT tresp) > 0 THEN COLLECT(DISTINCT {
                id: tresp.id,
                treatment_response_id: tresp.treatment_response_id,
                age_at_response: tresp.age_at_response,
                response: tresp.response,
                response_category: tresp.response_category,
                response_system: tresp.response_system
              })
              ELSE []
            END) AS treatment_responses,
            (CASE
              WHEN COUNT(DISTINCT s) > 0 THEN COLLECT(DISTINCT {
                id: s.id,
                sample_id: s.sample_id,
                anatomic_site: s.anatomic_site,
                participant_age_at_collection: s.participant_age_at_collection,
                sample_tumor_status: s.sample_tumor_status,
                tumor_classification: s.tumor_classification,
                sample_description: s.sample_description
              })
              ELSE []
            END) AS samples,
            (CASE
              WHEN COUNT(DISTINCT file) > 0 THEN COLLECT(DISTINCT {
                id: file.dcf_indexd_guid,
                file_id: CASE LABELS(file)[0]
                      WHEN 'clinical_measure_file' THEN file.dcf_indexd_guid
                      WHEN 'generic_file' THEN file.dcf_indexd_guid
                      WHEN 'radiology_file' THEN file.dcf_indexd_guid
                      WHEN 'sequencing_file' THEN file.dcf_indexd_guid
                      WHEN 'methylation_array_file' THEN file.dcf_indexd_guid
                      WHEN 'pathology_file' THEN file.dcf_indexd_guid
                      WHEN 'cytogenomic_file' THEN file.dcf_indexd_guid
                      ELSE null END,
                dcf_indexd_guid: file.dcf_indexd_guid,
                file_name: file.file_name,
                file_access: file.file_access,
                data_category: file.data_category,
                file_type: file.file_type,
                file_description: file.file_description,
                file_size: file.file_size,
                md5sum: file.md5sum,
                library_selection: CASE LABELS(file)[0]
                                    WHEN 'sequencing_file' THEN file.library_selection
                                    ELSE null END,
                library_source_material: CASE LABELS(file)[0]
                                    WHEN 'sequencing_file' THEN file.library_source_material
                                    ELSE null END,
                library_source_molecule: CASE LABELS(file)[0]
                                    WHEN 'sequencing_file' THEN file.library_source_molecule
                                    ELSE null END,
                library_strategy: CASE LABELS(file)[0]
                                    WHEN 'sequencing_file' THEN file.library_strategy
                                    ELSE null END
              })
              ELSE []
            END) AS files
        page_size: 100

  - index_name: study_participants
    type: neo4j
    mapping:
      id:
        type: keyword
      pid:
        type: keyword
      participant_id:
        type: keyword
      race:
        type: keyword
      sex_at_birth:
        type: keyword
      survival_filters:
        type: nested
        properties:
          last_known_survival_status:
            type: keyword
          age_at_last_known_survival_status:
            type: integer
          event_free_survival_status:
            type: keyword
          first_event:
            type: keyword
      treatment_filters:
        type: nested
        properties:
          treatment_type:
            type: keyword
          treatment_agent:
            type: keyword
          age_at_treatment_start:
            type: integer
      treatment_response_filters:
        type: nested
        properties:
          response_category:
            type: keyword
          age_at_response:
            type: integer
      sample_diagnosis_file_filters:
        type: nested
        properties:
          sample_anatomic_site:
            type: keyword
          participant_age_at_collection:
            type: integer
          sample_tumor_status:
            type: keyword
          tumor_classification:
            type: keyword
          age_at_diagnosis:
            type: integer
          diagnosis_anatomic_site:
            type: keyword
          disease_phase:
            type: keyword
          diagnosis_classification_system:
            type: keyword
          diagnosis_basis:
            type: keyword
          tumor_grade_source:
            type: keyword  
          tumor_stage_source:
            type: keyword            
          diagnosis:
            type: keyword
          diagnosis_category:
            type: keyword
          data_category:
            type: keyword
          file_type:
            type: keyword
          file_mapping_level:
            type: keyword
          library_selection:
            type: keyword
          library_source_material:
            type: keyword
          library_source_molecule:
            type: keyword
          library_strategy:
            type: keyword
      study_id:
        type: keyword
      dbgap_accession:
        type: keyword
      study_status:
        type: keyword
      study_acronym:
        type: keyword
      study_name:
        type: keyword
    # Cypher query will be used to retrieve data from Neo4j, and index into Elasticsearch
    cypher_queries:
      - query: |
          MATCH (p:participant)
          WITH p, {
            pid: p.id,
            participant_id: p.participant_id,
            race: apoc.text.split(p.race, ';'),
            sex_at_birth: p.sex_at_birth
          } AS opensearch_data
          SKIP $skip LIMIT $limit
          optional match (p)<--(sm:sample)
          optional match (p)<--(file)
          where (file: clinical_measure_file or file:generic_file or file: radiology_file)
          with distinct p, sm, file
          with p, CASE WHEN collect(sm) <> [] OR collect(file) <> [] THEN collect(DISTINCT {
                      sample_anatomic_site: apoc.text.split(sm.anatomic_site, ';'),
                      participant_age_at_collection: sm.participant_age_at_collection,
                      sample_tumor_status: sm.sample_tumor_status,
                      tumor_classification: sm.tumor_classification,
                      data_category: apoc.text.split(file.data_category, ';'),
                      file_type: file.file_type,
                      file_mapping_level: file.file_mapping_level,
                      library_selection: null,
                      library_source_material: null,
                      library_source_molecule: null,
                      library_strategy: null
              }) ELSE [] END as sample_clinical_radiology_file_filter
          optional match (p)<--(sm:sample)<--(file)
          where (file: sequencing_file or file: generic_file or file: methylation_array_file or file: pathology_file or file: cytogenomic_file)
          with p, sample_clinical_radiology_file_filter, CASE WHEN collect(sm) <> [] OR collect(file) <> [] THEN collect(DISTINCT {
                      sample_anatomic_site: apoc.text.split(sm.anatomic_site, ';'),
                      participant_age_at_collection: sm.participant_age_at_collection,
                      sample_tumor_status: sm.sample_tumor_status,
                      tumor_classification: sm.tumor_classification,
                      data_category: apoc.text.split(file.data_category, ';'),
                      file_type: file.file_type,
                      file_mapping_level: file.file_mapping_level,
                      library_selection: CASE LABELS(file)[0]
                                    WHEN 'sequencing_file' THEN file.library_selection
                                    ELSE null END,
                      library_source_material: CASE LABELS(file)[0]
                                            WHEN 'sequencing_file' THEN file.library_source_material
                                            ELSE null END,
                      library_source_molecule: CASE LABELS(file)[0]
                                            WHEN 'sequencing_file' THEN file.library_source_molecule
                                            ELSE null END,
                      library_strategy: CASE LABELS(file)[0]
                                    WHEN 'sequencing_file' THEN file.library_strategy
                                    ELSE null END
              }) ELSE [] END as sample_sequencing_cytogenomic_pathology_methylation_file_filter
            with p, apoc.coll.union(sample_clinical_radiology_file_filter, sample_sequencing_cytogenomic_pathology_methylation_file_filter) as sample_file_filters
            optional match (p)<--(dg:diagnosis)
            with p, CASE WHEN sample_file_filters IS NOT NULL AND sample_file_filters <> [] THEN sample_file_filters ELSE [null] END as sample_file_filters, dg
            unwind sample_file_filters as sample_file_filter
            with p, collect(apoc.map.merge(sample_file_filter, {
                age_at_diagnosis: dg.age_at_diagnosis,
                diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                disease_phase: dg.disease_phase,
                diagnosis_classification_system: dg.diagnosis_classification_system,
                diagnosis_category: apoc.text.split(dg.diagnosis_category, ';'),
                diagnosis_basis: dg.diagnosis_basis, 
                tumor_grade_source: dg.tumor_grade_source,
                tumor_stage_source: dg.tumor_stage_source,          
                diagnosis: dg.diagnosis
              })) as sample_diagnosis_file_filter
            optional match (p)<--(sm:sample)<--(dg:diagnosis)
            optional match (sm)<--(file)
            where (file: sequencing_file or file: generic_file or file: methylation_array_file or file: pathology_file or file: cytogenomic_file)
            with p, sample_diagnosis_file_filter, CASE WHEN collect(sm) <> [] OR collect(dg) <> [] OR collect(file) <> [] THEN COLLECT(DISTINCT {
                    sample_anatomic_site: apoc.text.split(sm.anatomic_site, ';'),
                    participant_age_at_collection: sm.participant_age_at_collection,
                    sample_tumor_status: sm.sample_tumor_status,
                    tumor_classification: sm.tumor_classification,
                    age_at_diagnosis: dg.age_at_diagnosis,
                    diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                    disease_phase: dg.disease_phase,
                    diagnosis_classification_system: dg.diagnosis_classification_system,
                    diagnosis_category: apoc.text.split(dg.diagnosis_category, ';'),
                    diagnosis_basis: dg.diagnosis_basis, 
                    tumor_grade_source: dg.tumor_grade_source,
                    tumor_stage_source: dg.tumor_stage_source,          
                    diagnosis: dg.diagnosis,
                    data_category: apoc.text.split(file.data_category, ';'),
                    file_type: file.file_type,
                    file_mapping_level: file.file_mapping_level,
                    library_selection: CASE LABELS(file)[0]
                              WHEN 'sequencing_file' THEN file.library_selection
                              ELSE null END,
                    library_source_material: CASE LABELS(file)[0]
                                    WHEN 'sequencing_file' THEN file.library_source_material
                                    ELSE null END,
                    library_source_molecule: CASE LABELS(file)[0]
                                    WHEN 'sequencing_file' THEN file.library_source_molecule
                                    ELSE null END,
                    library_strategy: CASE LABELS(file)[0]
                              WHEN 'sequencing_file' THEN file.library_strategy
                              ELSE null END
                }) ELSE [] END as sample_diagnosis_filters_1
            with p, apoc.coll.union(sample_diagnosis_file_filter, sample_diagnosis_filters_1) as sample_diagnosis_file_filters
            optional match (p)<--(sm:sample)<--(dg:diagnosis)
            optional match (p)<--(file)
            where (file: clinical_measure_file or file: generic_file or file: radiology_file)
            with p, sample_diagnosis_file_filters, CASE WHEN collect(sm) <> [] OR collect(dg)  <> [] OR collect(file)  <> [] THEN COLLECT(DISTINCT {
                    sample_anatomic_site: apoc.text.split(sm.anatomic_site, ';'),
                    participant_age_at_collection: sm.participant_age_at_collection,
                    sample_tumor_status: sm.sample_tumor_status,
                    tumor_classification: sm.tumor_classification,
                    age_at_diagnosis: dg.age_at_diagnosis,
                    diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                    disease_phase: dg.disease_phase,
                    diagnosis_classification_system: dg.diagnosis_classification_system,
                    diagnosis_category: apoc.text.split(dg.diagnosis_category, ';'),
                    diagnosis_basis: dg.diagnosis_basis, 
                    tumor_grade_source: dg.tumor_grade_source,
                    tumor_stage_source: dg.tumor_stage_source,          
                    diagnosis: dg.diagnosis,
                    data_category: apoc.text.split(file.data_category, ';'),
                    file_type: file.file_type,
                    file_mapping_level: file.file_mapping_level,
                    library_selection: null,
                    library_source_material: null,
                    library_source_molecule: null,
                    library_strategy: null
                }) ELSE [] END as sample_diagnosis_filters_2
            with p, apoc.coll.union(sample_diagnosis_file_filters, sample_diagnosis_filters_2) as sample_diagnosis_file_filter
          optional MATCH (p)<-[:of_sample]-(sm1:sample)<--(cl)<--(sm2:sample)
          WHERE (cl: cell_line or cl: pdx)
          optional Match (sm2)<--(file)
          WHERE (file: sequencing_file or file: generic_file OR file:pathology_file OR file:methylation_array_file OR file:cytogenomic_file)
          optional Match (sm1)<--(dg:diagnosis)
          with p, sample_diagnosis_file_filter, CASE WHEN collect(sm1) <> [] OR collect(dg) <> [] OR collect(file) <> [] THEN COLLECT(DISTINCT {
                    sample_anatomic_site: apoc.text.split(sm1.anatomic_site, ';'),
                    participant_age_at_collection: sm1.participant_age_at_collection,
                    sample_tumor_status: sm1.sample_tumor_status,
                    tumor_classification: sm1.tumor_classification,
                    age_at_diagnosis: dg.age_at_diagnosis,
                    diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                    disease_phase: dg.disease_phase,
                    diagnosis_classification_system: dg.diagnosis_classification_system,
                    diagnosis_category: apoc.text.split(dg.diagnosis_category, ';'),
                    diagnosis_basis: dg.diagnosis_basis, 
                    tumor_grade_source: dg.tumor_grade_source,
                    tumor_stage_source: dg.tumor_stage_source,          
                    diagnosis: dg.diagnosis,
                    data_category: apoc.text.split(file.data_category, ';'),
                    file_type: file.file_type,
                    file_mapping_level: file.file_mapping_level,
                    library_selection: CASE LABELS(file)[0]
                              WHEN 'sequencing_file' THEN file.library_selection
                              ELSE null END,
                    library_source_material: CASE LABELS(file)[0]
                                    WHEN 'sequencing_file' THEN file.library_source_material
                                    ELSE null END,
                    library_source_molecule: CASE LABELS(file)[0]
                                    WHEN 'sequencing_file' THEN file.library_source_molecule
                                    ELSE null END,
                    library_strategy: CASE LABELS(file)[0]
                              WHEN 'sequencing_file' THEN file.library_strategy
                              ELSE null END
                }) ELSE [] END as sample_diagnosis_filters_1
            with p, apoc.coll.union(sample_diagnosis_file_filter, sample_diagnosis_filters_1) as sample_diagnosis_file_filters
          optional MATCH (p)<-[:of_sample]-(sm1:sample)<--(cl)<--(sm2:sample)
          WHERE (cl: cell_line or cl: pdx)
          optional Match (sm2)<--(file)
          WHERE (file: sequencing_file or file: generic_file OR file:pathology_file OR file:methylation_array_file OR file:cytogenomic_file)
          optional Match (sm2)<--(dg:diagnosis)
          with p, sample_diagnosis_file_filters, CASE WHEN collect(sm2) <> [] OR collect(dg) <> [] OR collect(file) <> [] THEN COLLECT(DISTINCT {
                    sample_anatomic_site: apoc.text.split(sm2.anatomic_site, ';'),
                    participant_age_at_collection: sm2.participant_age_at_collection,
                    sample_tumor_status: sm2.sample_tumor_status,
                    tumor_classification: sm2.tumor_classification,
                    age_at_diagnosis: dg.age_at_diagnosis,
                    diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                    disease_phase: dg.disease_phase,
                    diagnosis_classification_system: dg.diagnosis_classification_system,
                    diagnosis_category: apoc.text.split(dg.diagnosis_category, ';'),
                    diagnosis_basis: dg.diagnosis_basis, 
                    tumor_grade_source: dg.tumor_grade_source,
                    tumor_stage_source: dg.tumor_stage_source,          
                    diagnosis: dg.diagnosis,
                    data_category: apoc.text.split(file.data_category, ';'),
                    file_type: file.file_type,
                    file_mapping_level: file.file_mapping_level,
                    library_selection: CASE LABELS(file)[0]
                              WHEN 'sequencing_file' THEN file.library_selection
                              ELSE null END,
                    library_source_material: CASE LABELS(file)[0]
                                    WHEN 'sequencing_file' THEN file.library_source_material
                                    ELSE null END,
                    library_source_molecule: CASE LABELS(file)[0]
                                    WHEN 'sequencing_file' THEN file.library_source_molecule
                                    ELSE null END,
                    library_strategy: CASE LABELS(file)[0]
                              WHEN 'sequencing_file' THEN file.library_strategy
                              ELSE null END
                }) ELSE [] END as sample_diagnosis_filters_2
            with p, apoc.coll.union(sample_diagnosis_file_filters, sample_diagnosis_filters_2) as sample_diagnosis_file_filter
          optional MATCH (p)<-[:of_sample]-(sm1:sample)<--(cl)<--(sm2:sample)
          WHERE (cl: cell_line or cl: pdx)
          optional Match (sm1)<--(dg:diagnosis)
          optional match (p)<--(file)
          where (file: clinical_measure_file or file: generic_file or file: radiology_file)
          with p, sample_diagnosis_file_filter, CASE WHEN collect(sm1) <> [] OR collect(dg) <> [] OR collect(file) <> [] THEN COLLECT(DISTINCT {
                    sample_anatomic_site: apoc.text.split(sm1.anatomic_site, ';'),
                    participant_age_at_collection: sm1.participant_age_at_collection,
                    sample_tumor_status: sm1.sample_tumor_status,
                    tumor_classification: sm1.tumor_classification,
                    age_at_diagnosis: dg.age_at_diagnosis,
                    diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                    disease_phase: dg.disease_phase,
                    diagnosis_classification_system: dg.diagnosis_classification_system,
                    diagnosis_category: apoc.text.split(dg.diagnosis_category, ';'),
                    diagnosis_basis: dg.diagnosis_basis, 
                    tumor_grade_source: dg.tumor_grade_source,
                    tumor_stage_source: dg.tumor_stage_source,          
                    diagnosis: dg.diagnosis,
                    data_category: apoc.text.split(file.data_category, ';'),
                    file_type: file.file_type,
                    file_mapping_level: file.file_mapping_level,
                    library_selection: null,
                    library_source_material: null,
                    library_source_molecule: null,
                    library_strategy: null
                }) ELSE [] END as sample_diagnosis_filters_3
            with p, apoc.coll.union(sample_diagnosis_file_filter, sample_diagnosis_filters_3) as sample_diagnosis_file_filters
          optional MATCH (p)<-[:of_sample]-(sm1:sample)<--(cl)<--(sm2:sample)
          WHERE (cl: cell_line or cl: pdx)
          optional Match (sm2)<--(dg:diagnosis)
          optional match (p)<--(file)
          where (file: clinical_measure_file or file: generic_file or file: radiology_file)
          with p, sample_diagnosis_file_filters, CASE WHEN collect(sm2) <> [] OR collect(dg) <> [] OR collect(file) <> [] THEN COLLECT(DISTINCT {
                    sample_anatomic_site: apoc.text.split(sm2.anatomic_site, ';'),
                    participant_age_at_collection: sm2.participant_age_at_collection,
                    sample_tumor_status: sm2.sample_tumor_status,
                    tumor_classification: sm2.tumor_classification,
                    age_at_diagnosis: dg.age_at_diagnosis,
                    diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                    disease_phase: dg.disease_phase,
                    diagnosis_classification_system: dg.diagnosis_classification_system,
                    diagnosis_category: apoc.text.split(dg.diagnosis_category, ';'),
                    diagnosis_basis: dg.diagnosis_basis, 
                    tumor_grade_source: dg.tumor_grade_source,
                    tumor_stage_source: dg.tumor_stage_source,          
                    diagnosis: dg.diagnosis,
                    data_category: apoc.text.split(file.data_category, ';'),
                    file_type: file.file_type,
                    file_mapping_level: file.file_mapping_level,
                    library_selection: null,
                    library_source_material: null,
                    library_source_molecule: null,
                    library_strategy: null
                }) ELSE [] END as sample_diagnosis_filters_4
          with p, apoc.coll.union(sample_diagnosis_file_filters, sample_diagnosis_filters_4) as sample_diagnosis_file_filter
          OPTIONAL MATCH (p)<-[:of_survival]-(su:survival)
          OPTIONAL MATCH (p)<-[:of_treatment]-(tm:treatment)
          OPTIONAL MATCH (p)<-[:of_treatment_response]-(tr:treatment_response)
          OPTIONAL MATCH (st:study)<-[:of_consent_group]-(cg:consent_group)<-[:of_participant]-(p)
          OPTIONAL MATCH (st)<-[:of_study_personnel]-(stp:study_personnel)
          OPTIONAL MATCH (st)<-[:of_study_funding]-(stf:study_funding)
          WITH p, sample_diagnosis_file_filter,  st, stf, stp,
          CASE WHEN su IS NOT NULL THEN COLLECT(DISTINCT {last_known_survival_status: su.last_known_survival_status, 
            event_free_survival_status: su.event_free_survival_status, 
            first_event: su.first_event,
            age_at_last_known_survival_status: su.age_at_last_known_survival_status} ) ELSE [] END as survival_filters,
          CASE WHEN tm IS NOT NULL THEN COLLECT(DISTINCT{treatment_type: apoc.text.split(tm.treatment_type, ';'),
          treatment_agent: apoc.text.split(tm.treatment_agent, ';'),
          age_at_treatment_start: tm.age_at_treatment_start}) ELSE [] END as treatment_filters,
          CASE WHEN tr IS NOT NULL THEN COLLECT(DISTINCT{response_category: tr.response_category, age_at_response: tr.age_at_response}) ELSE [] END as treatment_response_filters
          RETURN DISTINCT
            p.id as id,
            p.id as pid,
            p.participant_id as participant_id,
            apoc.text.split(p.race, ';') as race,
            p.sex_at_birth as sex_at_birth,
            survival_filters as survival_filters,
            treatment_filters as treatment_filters,
            treatment_response_filters as treatment_response_filters,
            sample_diagnosis_file_filter AS sample_diagnosis_file_filters,
            st.study_id as study_id,
            st.dbgap_accession as dbgap_accession,
            st.study_status AS study_status,
            st.study_acronym as study_acronym,
            st.study_name as study_name
        page_size: 1000
      - query: |
          MATCH (st:study)
          MATCH (st)<-[:of_clinical_measure_file]-(file:clinical_measure_file)
          OPTIONAL MATCH (st)<-[:of_study_personnel]-(stp:study_personnel)
          OPTIONAL MATCH (st)<-[:of_study_funding]-(stf:study_funding)
          WITH file, st, stf, stp
          RETURN DISTINCT
            null as id,
            null as pid,
            null as participant_id,
            null as race,
            null as sex_at_birth,
            COLLECT(DISTINCT {
                sample_anatomic_site: null,
                participant_age_at_collection: null,
                sample_tumor_status: null,
                tumor_classification: null,
                age_at_diagnosis: null,
                diagnosis_anatomic_site: null,
                disease_phase: null,
                diagnosis_classification_system: null,
                diagnosis_category: null,
                diagnosis_basis: null, 
                tumor_grade_source: null,
                tumor_stage_source: null,          
                diagnosis: null,
                data_category: apoc.text.split(file.data_category, ';'),
                file_type: file.file_type,
                file_mapping_level: file.file_mapping_level,
                library_selection: null,
                library_source_material: null,
                library_source_molecule: null,
                library_strategy: null
            }) AS sample_diagnosis_file_filters,
            [] AS survival_filters,
            [] as treatment_filters,
            [] as treatment_response_filters,            
            st.study_id as study_id,
            st.dbgap_accession as dbgap_accession,
            st.study_status AS study_status,
            st.study_acronym as study_acronym,
            st.study_name as study_name
      - query: |
          MATCH (st:study)
          MATCH (st)<-[:of_generic_file]-(file:generic_file)
          OPTIONAL MATCH (st)<-[:of_study_personnel]-(stp:study_personnel)
          OPTIONAL MATCH (st)<-[:of_study_funding]-(stf:study_funding)
          WITH file, st, stf, stp
          RETURN DISTINCT
            null as id,
            null as pid,
            null as participant_id,
            null as race,
            null as sex_at_birth,
            COLLECT(DISTINCT {
                sample_anatomic_site: null,
                participant_age_at_collection: null,
                sample_tumor_status: null,
                tumor_classification: null,
                age_at_diagnosis: null,
                diagnosis_anatomic_site: null,
                disease_phase: null,
                diagnosis_classification_system: null,
                diagnosis_category: null,
                diagnosis_basis: null, 
                tumor_grade_source: null,
                tumor_stage_source: null,          
                diagnosis: null,
                data_category: apoc.text.split(file.data_category, ';'),
                file_type: file.file_type,
                file_mapping_level: file.file_mapping_level,
                library_selection: null,
                library_source_material: null,
                library_source_molecule: null,
                library_strategy: null
            }) AS sample_diagnosis_file_filters,
            [] AS survival_filters,
            [] as treatment_filters,
            [] as treatment_response_filters,            
            st.study_id as study_id,
            st.dbgap_accession as dbgap_accession,
            st.study_status AS study_status,
            st.study_acronym as study_acronym,
            st.study_name as study_name
      - query: |
          MATCH (st:study)
          MATCH (st)<-[:of_cell_line|of_pdx]-(cl)<--(sm:sample)
          WHERE (cl:cell_line OR cl:pdx)
          OPTIONAL MATCH (sm)<--(dg:diagnosis)
          OPTIONAL MATCH (sm)<--(file)
          WHERE (file:sequencing_file or file: generic_file OR file:pathology_file OR file:methylation_array_file OR file:cytogenomic_file)
          OPTIONAL MATCH (st)<-[:of_study_personnel]-(stp:study_personnel)
          OPTIONAL MATCH (st)<-[:of_study_funding]-(stf:study_funding)
          WITH file, dg, sm, st, stf, stp
          RETURN DISTINCT
          null AS id,
          null AS pid,
          null AS participant_id,
          null AS race,
          null AS sex_at_birth,
          [] AS survival_filters,
          [] AS treatment_filters,
          [] AS treatment_response_filters,
          COLLECT(DISTINCT {
          sample_anatomic_site: apoc.text.split(sm.anatomic_site, ';'),
          participant_age_at_collection: sm.participant_age_at_collection,
          sample_tumor_status: sm.sample_tumor_status,
          tumor_classification: sm.tumor_classification,
          age_at_diagnosis: dg.age_at_diagnosis,
          diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
          disease_phase: dg.disease_phase,
          diagnosis_classification_system: dg.diagnosis_classification_system,
          diagnosis_category: apoc.text.split(dg.diagnosis_category, ';'),
          diagnosis_basis: dg.diagnosis_basis,
          tumor_grade_source: dg.tumor_grade_source,
          tumor_stage_source: dg.tumor_stage_source,
          diagnosis: dg.diagnosis,
          data_category: apoc.text.split(file.data_category, ';'),
          file_type: CASE LABELS(file)[0]
              WHEN null THEN null
              ELSE file.file_type END,
          file_mapping_level: file.file_mapping_level,
          library_selection: CASE LABELS(file)[0]
              WHEN 'sequencing_file' THEN file.library_selection
              ELSE null END,
          library_source_material: CASE LABELS(file)[0]
              WHEN 'sequencing_file' THEN file.library_source_material
              ELSE null END,
          library_source_molecule: CASE LABELS(file)[0]
              WHEN 'sequencing_file' THEN file.library_source_molecule
              ELSE null END,
          library_strategy: CASE LABELS(file)[0]
              WHEN 'sequencing_file' THEN file.library_strategy
              ELSE null END
          }) AS sample_diagnosis_file_filters,
          st.study_id AS study_id,
          st.dbgap_accession AS dbgap_accession,
          st.study_status AS study_status,
          st.study_acronym AS study_acronym,
          st.study_name AS study_name

  - index_name: participants
    type: neo4j
    mapping:
      id:
        type: keyword
      participant_id:
        type: keyword
        normalizer: lowercase
      race:
        type: keyword
      race_str:
        type: keyword
      sex_at_birth:
        type: keyword
      alternate_participant_id:
        type: keyword
      cpi_data:
        type: nested
        properties:
          associated_id:
            type: keyword
          repository_of_synonym_id:
            type: keyword
          domain_description:
            type: keyword
          domain_category:
            type: keyword
          data_location:
            type: keyword
          data_type:
            type: keyword
          p_id:
            type: keyword
      diagnosis_str:
        type: keyword
      diagnosis_category_str:
        type: keyword
      diagnosis_comment_str:
        type: keyword
      diagnosis_anatomic_site_str:
        type: keyword
      age_at_diagnosis_str:
        type: keyword
      treatment_agent_str:
        type: keyword
      treatment_type_str:
        type: keyword
      age_at_treatment_start_str:
        type: keyword
      first_event_str:
        type: keyword
      last_known_survival_status_str:
        type: keyword
      age_at_last_known_survival_status_str:
        type: keyword
      participant_id_gs:
        type: search_as_you_type
      diagnosis_str_gs:
        type: search_as_you_type
      diagnosis_category_str_gs:
        type: search_as_you_type
      study_id_gs:
        type: search_as_you_type
      age_at_diagnosis_str_gs:
        type: search_as_you_type
      treatment_type_str_gs:
        type: search_as_you_type
      sex_at_birth_gs:
        type: search_as_you_type
      treatment_agent_str_gs:
        type: search_as_you_type
      race_str_gs:
        type: search_as_you_type
      last_known_survival_status_str_gs:
        type: search_as_you_type
      survival_filters:
        type: nested
        properties:
          last_known_survival_status:
            type: keyword
          age_at_last_known_survival_status:
            type: integer
          event_free_survival_status:
            type: keyword
          first_event:
            type: keyword
      treatment_filters:
        type: nested
        properties:
          treatment_type:
            type: keyword
          treatment_agent:
            type: keyword
          age_at_treatment_start:
            type: integer
      treatment_response_filters:
        type: nested
        properties:
          response_category:
            type: keyword
          age_at_response:
            type: integer
      sample_diagnosis_file_filters:
        type: nested
        properties:
          sample_anatomic_site:
            type: keyword
          participant_age_at_collection:
            type: integer
          sample_tumor_status:
            type: keyword
          tumor_classification:
            type: keyword
          age_at_diagnosis:
            type: integer
          diagnosis_anatomic_site:
            type: keyword
          disease_phase:
            type: keyword
          diagnosis_classification_system:
            type: keyword
          diagnosis_basis:
            type: keyword
          tumor_grade_source:
            type: keyword  
          tumor_stage_source:
            type: keyword              
          diagnosis:
            type: keyword
          diagnosis_category:
            type: keyword
          data_category:
            type: keyword
          file_type:
            type: keyword
          file_mapping_level:
            type: keyword          
          library_selection:
            type: keyword
          library_source_material:
            type: keyword
          library_source_molecule:
            type: keyword
          library_strategy:
            type: keyword
      study_id:
        type: keyword
      dbgap_accession:
        type: keyword
      study_status:
        type: keyword
      study_acronym:
        type: keyword
      study_name:
        type: keyword
      file_count:
        type: integer
      files:
        type: text
        fields:
          keyword:
            type: keyword
    # Cypher query will be used to retrieve data from Neo4j, and index into Elasticsearch
    cypher_queries:
      - query: |
          MATCH (p:participant)
          WITH p, {
            pid: p.id,
            participant_id: p.participant_id,
            race: apoc.text.split(p.race, ';'),
            sex_at_birth: p.sex_at_birth
          } AS opensearch_data
          SKIP $skip LIMIT $limit
          optional match (p)<--(sm:sample)
          optional match (p)<--(file)
          where (file: clinical_measure_file or file: generic_file or file: radiology_file)
          with distinct p, sm, file
          with p, CASE WHEN collect(sm) <> [] OR collect(file) <> [] THEN collect(DISTINCT {
            sample_anatomic_site: apoc.text.split(sm.anatomic_site, ';'),
            participant_age_at_collection: sm.participant_age_at_collection,
            sample_tumor_status: sm.sample_tumor_status,
            tumor_classification: sm.tumor_classification,
            data_category: apoc.text.split(file.data_category, ';'),
            file_type: file.file_type,
            file_mapping_level: file.file_mapping_level,
            library_source_material: null,
            library_source_molecule: null,
            library_strategy: null
          }) ELSE [] END as sample_clinical_radiology_file_filter
          optional match (p)<--(sm:sample)<--(file)
          where (file: sequencing_file or file: generic_file or file: methylation_array_file or file: pathology_file or file: cytogenomic_file)
          with p, sample_clinical_radiology_file_filter, CASE WHEN collect(sm) <> [] OR collect(file) <> [] THEN collect(DISTINCT {
                      sample_anatomic_site: apoc.text.split(sm.anatomic_site, ';'),
                      participant_age_at_collection: sm.participant_age_at_collection,
                      sample_tumor_status: sm.sample_tumor_status,
                      tumor_classification: sm.tumor_classification,
                      data_category: apoc.text.split(file.data_category, ';'),
                      file_type: file.file_type,
                      file_mapping_level: file.file_mapping_level,
                      library_selection: CASE LABELS(file)[0]
                                    WHEN 'sequencing_file' THEN file.library_selection
                                    ELSE null END,
                      library_source_material: CASE LABELS(file)[0]
                                    WHEN 'sequencing_file' THEN file.library_source_material
                                    ELSE null END,
                      library_source_molecule: CASE LABELS(file)[0]
                                    WHEN 'sequencing_file' THEN file.library_source_molecule
                                    ELSE null END,
                      library_strategy: CASE LABELS(file)[0]
                                    WHEN 'sequencing_file' THEN file.library_strategy
                                    ELSE null END
              }) ELSE [] END as sample_sequencing_cytogenomic_pathology_methylation_file_filter
            with p, apoc.coll.union(sample_clinical_radiology_file_filter, sample_sequencing_cytogenomic_pathology_methylation_file_filter) as sample_file_filters
            optional match (p)<--(dg:diagnosis)
            with p, CASE WHEN sample_file_filters IS NOT NULL AND sample_file_filters <> [] THEN sample_file_filters ELSE [null] END as sample_file_filters, dg
            unwind sample_file_filters as sample_file_filter
            with p, collect(apoc.map.merge(sample_file_filter, {
                age_at_diagnosis: dg.age_at_diagnosis,
                diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                disease_phase: dg.disease_phase,
                diagnosis_classification_system: dg.diagnosis_classification_system,
                diagnosis_category: apoc.text.split(dg.diagnosis_category, ';'),
                diagnosis_basis: dg.diagnosis_basis, 
                tumor_grade_source: dg.tumor_grade_source,
                tumor_stage_source: dg.tumor_stage_source,          
                diagnosis: dg.diagnosis
              })) as sample_diagnosis_file_filter
            optional match (p)<--(sm:sample)<--(dg:diagnosis)
            optional match (sm)<--(file)
            where (file: sequencing_file or file: generic_file or file: methylation_array_file or file: pathology_file or file: cytogenomic_file)
            with p, sample_diagnosis_file_filter, CASE WHEN collect(sm) <> [] OR collect(dg) <> [] OR collect(file) <> [] THEN COLLECT(DISTINCT {
                    sample_anatomic_site: apoc.text.split(sm.anatomic_site, ';'),
                    participant_age_at_collection: sm.participant_age_at_collection,
                    sample_tumor_status: sm.sample_tumor_status,
                    tumor_classification: sm.tumor_classification,
                    age_at_diagnosis: dg.age_at_diagnosis,
                    diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                    disease_phase: dg.disease_phase,
                    diagnosis_classification_system: dg.diagnosis_classification_system,
                    diagnosis_category: apoc.text.split(dg.diagnosis_category, ';'),
                    diagnosis_basis: dg.diagnosis_basis, 
                    tumor_grade_source: dg.tumor_grade_source,
                    tumor_stage_source: dg.tumor_stage_source,          
                    diagnosis: dg.diagnosis,
                    data_category: apoc.text.split(file.data_category, ';'),
                    file_type: file.file_type,
                    file_mapping_level: file.file_mapping_level,
                    library_selection: CASE LABELS(file)[0]
                              WHEN 'sequencing_file' THEN file.library_selection
                              ELSE null END,
                    library_source_material: CASE LABELS(file)[0]
                                    WHEN 'sequencing_file' THEN file.library_source_material
                                    ELSE null END,
                    library_source_molecule: CASE LABELS(file)[0]
                                    WHEN 'sequencing_file' THEN file.library_source_molecule
                                    ELSE null END,
                    library_strategy: CASE LABELS(file)[0]
                              WHEN 'sequencing_file' THEN file.library_strategy
                              ELSE null END
                }) ELSE [] END as sample_diagnosis_filters_1
            with p, apoc.coll.union(sample_diagnosis_file_filter, sample_diagnosis_filters_1) as sample_diagnosis_file_filters
            optional match (p)<--(sm:sample)<--(dg:diagnosis)
            optional match (p)<--(file)
            where (file: clinical_measure_file or file: generic_file or file: radiology_file)
            with p, sample_diagnosis_file_filters, CASE WHEN collect(sm) <> [] OR collect(dg)  <> [] OR collect(file)  <> [] THEN COLLECT(DISTINCT {
                    sample_anatomic_site: apoc.text.split(sm.anatomic_site, ';'),
                    participant_age_at_collection: sm.participant_age_at_collection,
                    sample_tumor_status: sm.sample_tumor_status,
                    tumor_classification: sm.tumor_classification,
                    age_at_diagnosis: dg.age_at_diagnosis,
                    diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                    disease_phase: dg.disease_phase,
                    diagnosis_classification_system: dg.diagnosis_classification_system,
                    diagnosis_category: apoc.text.split(dg.diagnosis_category, ';'),
                    diagnosis_basis: dg.diagnosis_basis, 
                    tumor_grade_source: dg.tumor_grade_source,
                    tumor_stage_source: dg.tumor_stage_source,          
                    diagnosis: dg.diagnosis,
                    data_category: apoc.text.split(file.data_category, ';'),
                    file_type: file.file_type,
                    file_mapping_level: file.file_mapping_level,
                    library_selection: null,
                    library_source_material: null,
                    library_source_molecule: null,
                    library_strategy: null
                }) ELSE [] END as sample_diagnosis_filters_2
            with p, apoc.coll.union(sample_diagnosis_file_filters, sample_diagnosis_filters_2) as sample_diagnosis_file_filter
          optional MATCH (p)<-[:of_sample]-(sm1:sample)<--(cl)<--(sm2:sample)
          WHERE (cl: cell_line or cl: pdx)
          optional Match (sm2)<--(file)
          WHERE (file: sequencing_file or file: generic_file OR file:pathology_file OR file:methylation_array_file OR file:cytogenomic_file)
          optional Match (sm1)<--(dg:diagnosis)
          with p, sample_diagnosis_file_filter, CASE WHEN collect(sm1) <> [] OR collect(dg) <> [] OR collect(file) <> [] THEN COLLECT(DISTINCT {
                    sample_anatomic_site: apoc.text.split(sm1.anatomic_site, ';'),
                    participant_age_at_collection: sm1.participant_age_at_collection,
                    sample_tumor_status: sm1.sample_tumor_status,
                    tumor_classification: sm1.tumor_classification,
                    age_at_diagnosis: dg.age_at_diagnosis,
                    diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                    disease_phase: dg.disease_phase,
                    diagnosis_classification_system: dg.diagnosis_classification_system,
                    diagnosis_category: apoc.text.split(dg.diagnosis_category, ';'),
                    diagnosis_basis: dg.diagnosis_basis, 
                    tumor_grade_source: dg.tumor_grade_source,
                    tumor_stage_source: dg.tumor_stage_source,          
                    diagnosis: dg.diagnosis,
                    data_category: apoc.text.split(file.data_category, ';'),
                    file_type: file.file_type,
                    file_mapping_level: file.file_mapping_level,
                    library_selection: CASE LABELS(file)[0]
                              WHEN 'sequencing_file' THEN file.library_selection
                              ELSE null END,
                    library_source_material: CASE LABELS(file)[0]
                                    WHEN 'sequencing_file' THEN file.library_source_material
                                    ELSE null END,
                    library_source_molecule: CASE LABELS(file)[0]
                                    WHEN 'sequencing_file' THEN file.library_source_molecule
                                    ELSE null END,
                    library_strategy: CASE LABELS(file)[0]
                              WHEN 'sequencing_file' THEN file.library_strategy
                              ELSE null END
                }) ELSE [] END as sample_diagnosis_filters_1
            with p, apoc.coll.union(sample_diagnosis_file_filter, sample_diagnosis_filters_1) as sample_diagnosis_file_filters
          optional MATCH (p)<-[:of_sample]-(sm1:sample)<--(cl)<--(sm2:sample)
          WHERE (cl: cell_line or cl: pdx)
          optional Match (sm2)<--(file)
          WHERE (file: sequencing_file or file: generic_file OR file:pathology_file OR file:methylation_array_file OR file:cytogenomic_file)
          optional Match (sm2)<--(dg:diagnosis)
          with p, sample_diagnosis_file_filters, CASE WHEN collect(sm2) <> [] OR collect(dg) <> [] OR collect(file) <> [] THEN COLLECT(DISTINCT {
                    sample_anatomic_site: apoc.text.split(sm2.anatomic_site, ';'),
                    participant_age_at_collection: sm2.participant_age_at_collection,
                    sample_tumor_status: sm2.sample_tumor_status,
                    tumor_classification: sm2.tumor_classification,
                    age_at_diagnosis: dg.age_at_diagnosis,
                    diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                    disease_phase: dg.disease_phase,
                    diagnosis_classification_system: dg.diagnosis_classification_system,
                    diagnosis_category: apoc.text.split(dg.diagnosis_category, ';'),
                    diagnosis_basis: dg.diagnosis_basis, 
                    tumor_grade_source: dg.tumor_grade_source,
                    tumor_stage_source: dg.tumor_stage_source,          
                    diagnosis: dg.diagnosis,
                    data_category: apoc.text.split(file.data_category, ';'),
                    file_type: file.file_type,
                    file_mapping_level: file.file_mapping_level,
                    library_selection: CASE LABELS(file)[0]
                              WHEN 'sequencing_file' THEN file.library_selection
                              ELSE null END,
                    library_source_material: CASE LABELS(file)[0]
                                    WHEN 'sequencing_file' THEN file.library_source_material
                                    ELSE null END,
                    library_source_molecule: CASE LABELS(file)[0]
                                    WHEN 'sequencing_file' THEN file.library_source_molecule
                                    ELSE null END,
                    library_strategy: CASE LABELS(file)[0]
                              WHEN 'sequencing_file' THEN file.library_strategy
                              ELSE null END
                }) ELSE [] END as sample_diagnosis_filters_2
            with p, apoc.coll.union(sample_diagnosis_file_filters, sample_diagnosis_filters_2) as sample_diagnosis_file_filter
          optional MATCH (p)<-[:of_sample]-(sm1:sample)<--(cl)<--(sm2:sample)
          WHERE (cl: cell_line or cl: pdx)
          optional Match (sm1)<--(dg:diagnosis)
          optional match (p)<--(file)
          where (file: clinical_measure_file or file: generic_file or file: radiology_file)
          with p, sample_diagnosis_file_filter, CASE WHEN collect(sm1) <> [] OR collect(dg) <> [] OR collect(file) <> [] THEN COLLECT(DISTINCT {
                    sample_anatomic_site: apoc.text.split(sm1.anatomic_site, ';'),
                    participant_age_at_collection: sm1.participant_age_at_collection,
                    sample_tumor_status: sm1.sample_tumor_status,
                    tumor_classification: sm1.tumor_classification,
                    age_at_diagnosis: dg.age_at_diagnosis,
                    diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                    disease_phase: dg.disease_phase,
                    diagnosis_classification_system: dg.diagnosis_classification_system,
                    diagnosis_category: apoc.text.split(dg.diagnosis_category, ';'),
                    diagnosis_basis: dg.diagnosis_basis, 
                    tumor_grade_source: dg.tumor_grade_source,
                    tumor_stage_source: dg.tumor_stage_source,          
                    diagnosis: dg.diagnosis,
                    data_category: apoc.text.split(file.data_category, ';'),
                    file_type: file.file_type,
                    file_mapping_level: file.file_mapping_level,
                    library_selection: null,
                    library_source_material: null,
                    library_source_molecule: null,
                    library_strategy: null
                }) ELSE [] END as sample_diagnosis_filters_3
            with p, apoc.coll.union(sample_diagnosis_file_filter, sample_diagnosis_filters_3) as sample_diagnosis_file_filters
          optional MATCH (p)<-[:of_sample]-(sm1:sample)<--(cl)<--(sm2:sample)
          WHERE (cl: cell_line or cl: pdx)
          optional Match (sm2)<--(dg:diagnosis)
          optional match (p)<--(file)
          where (file: clinical_measure_file or file: generic_file or file: radiology_file)
          with p, sample_diagnosis_file_filters, CASE WHEN collect(sm2) <> [] OR collect(dg) <> [] OR collect(file) <> [] THEN COLLECT(DISTINCT {
                    sample_anatomic_site: apoc.text.split(sm2.anatomic_site, ';'),
                    participant_age_at_collection: sm2.participant_age_at_collection,
                    sample_tumor_status: sm2.sample_tumor_status,
                    tumor_classification: sm2.tumor_classification,
                    age_at_diagnosis: dg.age_at_diagnosis,
                    diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                    disease_phase: dg.disease_phase,
                    diagnosis_classification_system: dg.diagnosis_classification_system,
                    diagnosis_category: apoc.text.split(dg.diagnosis_category, ';'),
                    diagnosis_basis: dg.diagnosis_basis, 
                    tumor_grade_source: dg.tumor_grade_source,
                    tumor_stage_source: dg.tumor_stage_source,          
                    diagnosis: dg.diagnosis,
                    data_category: apoc.text.split(file.data_category, ';'),
                    file_type: file.file_type,
                    file_mapping_level: file.file_mapping_level,
                    library_selection: null,
                    library_source_material: null,
                    library_source_molecule: null,
                    library_strategy: null
                }) ELSE [] END as sample_diagnosis_filters_4
          with p, apoc.coll.union(sample_diagnosis_file_filters, sample_diagnosis_filters_4) as sample_diagnosis_file_filter
          OPTIONAL MATCH (std:study)
          with p, sample_diagnosis_file_filter
          OPTIONAL MATCH (p)<-[*..4]-(file)
          WHERE (file:clinical_measure_file or file: generic_file OR file: sequencing_file OR file:pathology_file OR file:radiology_file OR file:methylation_array_file OR file:cytogenomic_file)
          OPTIONAL MATCH (p)<-[:of_survival]-(su:survival)
          OPTIONAL MATCH (p)<-[:of_treatment]-(tm:treatment)
          OPTIONAL MATCH (p)<-[:of_treatment_response]-(tr:treatment_response)
          OPTIONAL MATCH (st:study)<-[:of_consent_group]-(cg:consent_group)<-[:of_participant]-(p)
          OPTIONAL MATCH (st)<-[:of_study_personnel]-(stp:study_personnel)
          OPTIONAL MATCH (st)<-[:of_study_funding]-(stf:study_funding)
          OPTIONAL MATCH (d:diagnosis)-[:of_diagnosis]->(p)
          WITH p, sample_diagnosis_file_filter, 
          // same for survival, treatment, and treatment_response, if they do not exist, return empty list
          CASE WHEN su IS NOT NULL THEN COLLECT(DISTINCT {last_known_survival_status: su.last_known_survival_status, 
            event_free_survival_status: su.event_free_survival_status, 
            first_event: su.first_event,
            age_at_last_known_survival_status: su.age_at_last_known_survival_status} ) ELSE [] END as survival_filters,
          CASE WHEN tm IS NOT NULL THEN COLLECT(DISTINCT{treatment_type: apoc.text.split(tm.treatment_type, ';'),
          treatment_agent: apoc.text.split(tm.treatment_agent, ';'),
          age_at_treatment_start: tm.age_at_treatment_start}) ELSE [] END as treatment_filters,
          CASE WHEN tr IS NOT NULL THEN COLLECT(DISTINCT{response_category: tr.response_category, age_at_response: tr.age_at_response}) ELSE [] END as treatment_response_filters,
          file, st, stf, stp,
          '' as alternate_participant_id,
          [] as cpi_data,
          apoc.text.join(COLLECT(distinct d.diagnosis), ';') AS diagnosis_str,
          apoc.text.join([x IN COLLECT(distinct d.diagnosis_category) WHERE x <> ""], ';') AS diagnosis_category_str,
          apoc.text.join(COLLECT(distinct d.diagnosis_comment), ';') AS diagnosis_comment_str,
          apoc.text.join([x IN COLLECT(distinct d.anatomic_site) WHERE x <> ""], ';') AS diagnosis_anatomic_site_str,
          apoc.text.join(COLLECT(distinct toString(case d.age_at_diagnosis when -999 then 'Not Reported' else coalesce(d.age_at_diagnosis, '') end)), ';') AS age_at_diagnosis_str,
          apoc.text.join([x IN COLLECT(distinct tm.treatment_agent) WHERE x <> ""], ';') as treatment_agent_str,
          apoc.text.join([x IN COLLECT(distinct tm.treatment_type) WHERE x <> ""], ';') as treatment_type_str,
          apoc.text.join(COLLECT(distinct toString(case tm.age_at_treatment_start when -999 then 'Not Reported' else coalesce(tm.age_at_treatment_start, '') end)), ';') AS age_at_treatment_start_str,
          apoc.text.join(COLLECT(distinct su.first_event), ';') AS first_event_str,
          apoc.text.join(COLLECT(distinct su.last_known_survival_status), ';') AS last_known_survival_status_str,
          apoc.text.join(COLLECT(distinct toString(case su.age_at_last_known_survival_status when -999 then 'Not Reported' else coalesce(su.age_at_last_known_survival_status, '') end)), ';') AS age_at_last_known_survival_status_str
          RETURN DISTINCT
            p.id as id,
            p.participant_id as participant_id,
            apoc.text.split(p.race, ';') as race,
            p.race as race_str,
            p.sex_at_birth as sex_at_birth,
            alternate_participant_id as alternate_participant_id,
            cpi_data as cpi_data,
            diagnosis_str as diagnosis_str,
            diagnosis_category_str as diagnosis_category_str,
            diagnosis_comment_str as diagnosis_comment_str,
            diagnosis_anatomic_site_str as diagnosis_anatomic_site_str,
            age_at_diagnosis_str as age_at_diagnosis_str,
            treatment_agent_str as treatment_agent_str,
            treatment_type_str as treatment_type_str,
            age_at_treatment_start_str as age_at_treatment_start_str,
            first_event_str as first_event_str,
            last_known_survival_status_str as last_known_survival_status_str,
            age_at_last_known_survival_status_str as age_at_last_known_survival_status_str,
            p.participant_id as participant_id_gs,
            diagnosis_str as diagnosis_str_gs,
            diagnosis_category_str as diagnosis_category_str_gs,
            st.study_id as study_id_gs,
            age_at_diagnosis_str as age_at_diagnosis_str_gs,
            treatment_type_str as treatment_type_str_gs,
            p.sex_at_birth as sex_at_birth_gs,
            treatment_agent_str as treatment_agent_str_gs,
            p.race as race_str_gs,
            last_known_survival_status_str as last_known_survival_status_str_gs,
            survival_filters as survival_filters,
            treatment_filters as treatment_filters,
            treatment_response_filters as treatment_response_filters,
            sample_diagnosis_file_filter AS sample_diagnosis_file_filters,
            st.study_id as study_id,
            st.dbgap_accession as dbgap_accession,
            st.study_status AS study_status,
            st.study_acronym as study_acronym,
            st.study_name as study_name,
            COUNT(DISTINCT file.dcf_indexd_guid) as file_count,
            COLLECT(DISTINCT file.dcf_indexd_guid) as files
        page_size: 1000
          

  - index_name: survivals
    type: neo4j
    mapping:
      id:
        type: keyword
      pid:
        type: keyword
      participant_id:
        type: keyword
        normalizer: lowercase
      race:
        type: keyword
      sex_at_birth:
        type: keyword
      last_known_survival_status:
        type: keyword
      age_at_last_known_survival_status:
        type: integer
      event_free_survival_status:
        type: keyword
      first_event:
        type: keyword
      treatment_filters:
        type: nested
        properties:
          treatment_type:
            type: keyword
          treatment_agent:
            type: keyword
          age_at_treatment_start:
            type: integer
      treatment_response_filters:
        type: nested
        properties:
          response_category:
            type: keyword
          age_at_response:
            type: integer
      sample_diagnosis_file_filters:
        type: nested
        properties:
          sample_anatomic_site:
            type: keyword
          participant_age_at_collection:
            type: integer
          sample_tumor_status:
            type: keyword
          tumor_classification:
            type: keyword
          age_at_diagnosis:
            type: integer
          diagnosis_anatomic_site:
            type: keyword
          disease_phase:
            type: keyword
          diagnosis_classification_system:
            type: keyword
          diagnosis_basis:
            type: keyword
          tumor_grade_source:
            type: keyword  
          tumor_stage_source:
            type: keyword              
          diagnosis:
            type: keyword
          diagnosis_category:
            type: keyword
          data_category:
            type: keyword
          file_type:
            type: keyword
          file_mapping_level:
            type: keyword            
          library_selection:
            type: keyword
          library_source_material:
            type: keyword
          library_source_molecule:
            type: keyword
          library_strategy:
            type: keyword
      study_id:
        type: keyword
      dbgap_accession:
        type: keyword
      study_status:
        type: keyword
      study_acronym:
        type: keyword
      study_name:
        type: keyword
    # Cypher query will be used to retrieve data from Neo4j, and index into Elasticsearch
    cypher_queries:
      - query: |
          MATCH (p:participant)
          optional match (p)<--(sm:sample)
          optional match (p)<--(file)
          where (file: clinical_measure_file or file: generic_file or file: radiology_file)
          with distinct p, sm, file
          with p, collect(DISTINCT {
                      sample_anatomic_site: apoc.text.split(sm.anatomic_site, ';'),
                      participant_age_at_collection: sm.participant_age_at_collection,
                      sample_tumor_status: sm.sample_tumor_status,
                      tumor_classification: sm.tumor_classification,
                      data_category: apoc.text.split(file.data_category, ';'),
                      file_type: file.file_type,
                      file_mapping_level: file.file_mapping_level,
                      library_source_material: null,
                      library_source_molecule: null,
                      library_strategy: null
              }) as sample_clinical_radiology_file_filter
          optional match (p)<--(sm:sample)<--(file)
          where (file: sequencing_file or file: generic_file or file: methylation_array_file or file: pathology_file or file: cytogenomic_file)
          with p, sample_clinical_radiology_file_filter, collect(DISTINCT {
                      sample_anatomic_site: apoc.text.split(sm.anatomic_site, ';'),
                      participant_age_at_collection: sm.participant_age_at_collection,
                      sample_tumor_status: sm.sample_tumor_status,
                      tumor_classification: sm.tumor_classification,
                      data_category: apoc.text.split(file.data_category, ';'),
                      file_type: file.file_type,
                      file_mapping_level: file.file_mapping_level,
                      library_selection: CASE LABELS(file)[0]
                                    WHEN 'sequencing_file' THEN file.library_selection
                                    ELSE null END,
                      library_source_material: CASE LABELS(file)[0]
                                    WHEN 'sequencing_file' THEN file.library_source_material
                                    ELSE null END,
                      library_source_molecule: CASE LABELS(file)[0]
                                    WHEN 'sequencing_file' THEN file.library_source_molecule
                                    ELSE null END,
                      library_strategy: CASE LABELS(file)[0]
                                    WHEN 'sequencing_file' THEN file.library_strategy
                                    ELSE null END
              }) as sample_sequencing_cytogenomic_pathology_methylation_file_filter
            with p, apoc.coll.union(sample_clinical_radiology_file_filter, sample_sequencing_cytogenomic_pathology_methylation_file_filter) as sample_file_filters
            optional match (p)<--(dg:diagnosis)
            with p, sample_file_filters, dg
            unwind sample_file_filters as sample_file_filter
            with p, collect(apoc.map.merge(sample_file_filter, {
                age_at_diagnosis: dg.age_at_diagnosis,
                diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                disease_phase: dg.disease_phase,
                diagnosis_classification_system: dg.diagnosis_classification_system,
                diagnosis_category: apoc.text.split(dg.diagnosis_category, ';'),
                diagnosis_basis: dg.diagnosis_basis, 
                tumor_grade_source: dg.tumor_grade_source,
                tumor_stage_source: dg.tumor_stage_source,          
                diagnosis: dg.diagnosis
              })) as sample_diagnosis_file_filter
            optional match (p)<--(sm:sample)<--(dg:diagnosis)
            optional match (sm)<--(file)
            where (file: sequencing_file or file: generic_file or file: methylation_array_file or file: pathology_file or file: cytogenomic_file)
            with p, sample_diagnosis_file_filter, COLLECT(DISTINCT {
                    sample_anatomic_site: apoc.text.split(sm.anatomic_site, ';'),
                    participant_age_at_collection: sm.participant_age_at_collection,
                    sample_tumor_status: sm.sample_tumor_status,
                    tumor_classification: sm.tumor_classification,
                    age_at_diagnosis: dg.age_at_diagnosis,
                    diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                    disease_phase: dg.disease_phase,
                    diagnosis_classification_system: dg.diagnosis_classification_system,
                    diagnosis_category: apoc.text.split(dg.diagnosis_category, ';'),
                    diagnosis_basis: dg.diagnosis_basis, 
                    tumor_grade_source: dg.tumor_grade_source,
                    tumor_stage_source: dg.tumor_stage_source,          
                    diagnosis: dg.diagnosis,
                    data_category: apoc.text.split(file.data_category, ';'),
                    file_type: file.file_type,
                    file_mapping_level: file.file_mapping_level,
                    library_selection: CASE LABELS(file)[0]
                              WHEN 'sequencing_file' THEN file.library_selection
                              ELSE null END,
                    library_source_material: CASE LABELS(file)[0]
                                    WHEN 'sequencing_file' THEN file.library_source_material
                                    ELSE null END,
                    library_source_molecule: CASE LABELS(file)[0]
                                    WHEN 'sequencing_file' THEN file.library_source_molecule
                                    ELSE null END,
                    library_strategy: CASE LABELS(file)[0]
                              WHEN 'sequencing_file' THEN file.library_strategy
                              ELSE null END
                }) AS sample_diagnosis_filters_1
            with p, apoc.coll.union(sample_diagnosis_file_filter, sample_diagnosis_filters_1) as sample_diagnosis_file_filters
            optional match (p)<--(sm:sample)<--(dg:diagnosis)
            optional match (p)<--(file)
            where (file: clinical_measure_file or file: generic_file or file: radiology_file)
            with p, sample_diagnosis_file_filters, COLLECT(DISTINCT {
                    sample_anatomic_site: apoc.text.split(sm.anatomic_site, ';'),
                    participant_age_at_collection: sm.participant_age_at_collection,
                    sample_tumor_status: sm.sample_tumor_status,
                    tumor_classification: sm.tumor_classification,
                    age_at_diagnosis: dg.age_at_diagnosis,
                    diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                    disease_phase: dg.disease_phase,
                    diagnosis_classification_system: dg.diagnosis_classification_system,
                    diagnosis_basis: dg.diagnosis_basis,
                    diagnosis_category: apoc.text.split(dg.diagnosis_category, ';'),
                    tumor_grade_source: dg.tumor_grade_source,
                    tumor_stage_source: dg.tumor_stage_source,          
                    diagnosis: dg.diagnosis,
                    data_category: apoc.text.split(file.data_category, ';'),
                    file_type: file.file_type,
                    file_mapping_level: file.file_mapping_level,
                    library_selection: null,
                    library_source_material: null,
                    library_source_molecule: null,
                    library_strategy: null
                }) AS sample_diagnosis_filters_2
            with p, apoc.coll.union(sample_diagnosis_file_filters, sample_diagnosis_filters_2) as sample_diagnosis_file_filter
          optional MATCH (p)<-[:of_sample]-(sm1:sample)<--(cl)<--(sm2:sample)
          WHERE (cl: cell_line or cl: pdx)
          optional Match (sm2)<--(file)
          WHERE (file: sequencing_file or file: generic_file OR file:pathology_file OR file:methylation_array_file OR file:cytogenomic_file)
          optional Match (sm1)<--(dg:diagnosis)
          with p, sample_diagnosis_file_filter, COLLECT(DISTINCT {
                    sample_anatomic_site: apoc.text.split(sm1.anatomic_site, ';'),
                    participant_age_at_collection: sm1.participant_age_at_collection,
                    sample_tumor_status: sm1.sample_tumor_status,
                    tumor_classification: sm1.tumor_classification,
                    age_at_diagnosis: dg.age_at_diagnosis,
                    diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                    disease_phase: dg.disease_phase,
                    diagnosis_classification_system: dg.diagnosis_classification_system,
                    diagnosis_category: apoc.text.split(dg.diagnosis_category, ';'),
                    diagnosis_basis: dg.diagnosis_basis, 
                    tumor_grade_source: dg.tumor_grade_source,
                    tumor_stage_source: dg.tumor_stage_source,          
                    diagnosis: dg.diagnosis,
                    data_category: apoc.text.split(file.data_category, ';'),
                    file_type: file.file_type,
                    file_mapping_level: file.file_mapping_level,
                    library_selection: CASE LABELS(file)[0]
                              WHEN 'sequencing_file' THEN file.library_selection
                              ELSE null END,
                    library_source_material: CASE LABELS(file)[0]
                                    WHEN 'sequencing_file' THEN file.library_source_material
                                    ELSE null END,
                    library_source_molecule: CASE LABELS(file)[0]
                                    WHEN 'sequencing_file' THEN file.library_source_molecule
                                    ELSE null END,
                    library_strategy: CASE LABELS(file)[0]
                              WHEN 'sequencing_file' THEN file.library_strategy
                              ELSE null END
                }) AS sample_diagnosis_filters_1
            with p, apoc.coll.union(sample_diagnosis_file_filter, sample_diagnosis_filters_1) as sample_diagnosis_file_filters
          optional MATCH (p)<-[:of_sample]-(sm1:sample)<--(cl)<--(sm2:sample)
          WHERE (cl: cell_line or cl: pdx)
          optional Match (sm2)<--(file)
          WHERE (file: sequencing_file or file: generic_file OR file:pathology_file OR file:methylation_array_file OR file:cytogenomic_file)
          optional Match (sm2)<--(dg:diagnosis)
          with p, sample_diagnosis_file_filters, COLLECT(DISTINCT {
                    sample_anatomic_site: apoc.text.split(sm2.anatomic_site, ';'),
                    participant_age_at_collection: sm2.participant_age_at_collection,
                    sample_tumor_status: sm2.sample_tumor_status,
                    tumor_classification: sm2.tumor_classification,
                    age_at_diagnosis: dg.age_at_diagnosis,
                    diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                    disease_phase: dg.disease_phase,
                    diagnosis_classification_system: dg.diagnosis_classification_system,
                    diagnosis_category: apoc.text.split(dg.diagnosis_category, ';'),
                    diagnosis_basis: dg.diagnosis_basis, 
                    tumor_grade_source: dg.tumor_grade_source,
                    tumor_stage_source: dg.tumor_stage_source,          
                    diagnosis: dg.diagnosis,
                    data_category: apoc.text.split(file.data_category, ';'),
                    file_type: file.file_type,
                    file_mapping_level: file.file_mapping_level,
                    library_selection: CASE LABELS(file)[0]
                              WHEN 'sequencing_file' THEN file.library_selection
                              ELSE null END,
                    library_source_material: CASE LABELS(file)[0]
                                    WHEN 'sequencing_file' THEN file.library_source_material
                                    ELSE null END,
                    library_source_molecule: CASE LABELS(file)[0]
                                    WHEN 'sequencing_file' THEN file.library_source_molecule
                                    ELSE null END,
                    library_strategy: CASE LABELS(file)[0]
                              WHEN 'sequencing_file' THEN file.library_strategy
                              ELSE null END
                }) AS sample_diagnosis_filters_2
            with p, apoc.coll.union(sample_diagnosis_file_filters, sample_diagnosis_filters_2) as sample_diagnosis_file_filter
          optional MATCH (p)<-[:of_sample]-(sm1:sample)<--(cl)<--(sm2:sample)
          WHERE (cl: cell_line or cl: pdx)
          optional Match (sm1)<--(dg:diagnosis)
          optional match (p)<--(file)
          where (file: clinical_measure_file or file: generic_file or file: radiology_file)
          with p, sample_diagnosis_file_filter, COLLECT(DISTINCT {
                    sample_anatomic_site: apoc.text.split(sm1.anatomic_site, ';'),
                    participant_age_at_collection: sm1.participant_age_at_collection,
                    sample_tumor_status: sm1.sample_tumor_status,
                    tumor_classification: sm1.tumor_classification,
                    age_at_diagnosis: dg.age_at_diagnosis,
                    diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                    disease_phase: dg.disease_phase,
                    diagnosis_classification_system: dg.diagnosis_classification_system,
                    diagnosis_category: apoc.text.split(dg.diagnosis_category, ';'),
                    diagnosis_basis: dg.diagnosis_basis, 
                    tumor_grade_source: dg.tumor_grade_source,
                    tumor_stage_source: dg.tumor_stage_source,          
                    diagnosis: dg.diagnosis,
                    data_category: apoc.text.split(file.data_category, ';'),
                    file_type: file.file_type,
                    file_mapping_level: file.file_mapping_level,
                    library_selection: null,
                    library_source_material: null,
                    library_source_molecule: null,
                    library_strategy: null
                }) AS sample_diagnosis_filters_3
            with p, apoc.coll.union(sample_diagnosis_file_filter, sample_diagnosis_filters_3) as sample_diagnosis_file_filters
          optional MATCH (p)<-[:of_sample]-(sm1:sample)<--(cl)<--(sm2:sample)
          WHERE (cl: cell_line or cl: pdx)
          optional Match (sm2)<--(dg:diagnosis)
          optional match (p)<--(file)
          where (file: clinical_measure_file or file: generic_file or file: radiology_file)
          with p, sample_diagnosis_file_filters, COLLECT(DISTINCT {
                    sample_anatomic_site: apoc.text.split(sm2.anatomic_site, ';'),
                    participant_age_at_collection: sm2.participant_age_at_collection,
                    sample_tumor_status: sm2.sample_tumor_status,
                    tumor_classification: sm2.tumor_classification,
                    age_at_diagnosis: dg.age_at_diagnosis,
                    diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                    disease_phase: dg.disease_phase,
                    diagnosis_classification_system: dg.diagnosis_classification_system,
                    diagnosis_category: apoc.text.split(dg.diagnosis_category, ';'),
                    diagnosis_basis: dg.diagnosis_basis, 
                    tumor_grade_source: dg.tumor_grade_source,
                    tumor_stage_source: dg.tumor_stage_source,          
                    diagnosis: dg.diagnosis,
                    data_category: apoc.text.split(file.data_category, ';'),
                    file_type: file.file_type,
                    file_mapping_level: file.file_mapping_level,
                    library_selection: null,
                    library_source_material: null,
                    library_source_molecule: null,
                    library_strategy: null
                }) AS sample_diagnosis_filters_4
            with p, apoc.coll.union(sample_diagnosis_file_filters, sample_diagnosis_filters_4) as sample_diagnosis_file_filter
            MATCH (p)<-[:of_survival]-(su:survival)
            OPTIONAL MATCH (p)<-[:of_treatment]-(tm:treatment)
            OPTIONAL MATCH (p)<-[:of_treatment_response]-(tr:treatment_response)
            OPTIONAL MATCH (p)<-[:of_synonym]-(sy:synonym)
            OPTIONAL MATCH (st:study)<-[:of_consent_group]-(cg:consent_group)<-[:of_participant]-(p)
            OPTIONAL MATCH (st)<-[:of_study_personnel]-(stp:study_personnel)
            OPTIONAL MATCH (st)<-[:of_study_funding]-(stf:study_funding)
            WITH su, p, sy, sample_diagnosis_file_filter,  
            COLLECT(DISTINCT{treatment_type: apoc.text.split(tm.treatment_type, ';'),
            treatment_agent: apoc.text.split(tm.treatment_agent, ';'),
            age_at_treatment_start: tm.age_at_treatment_start}) as treatment_filters,
            COLLECT(DISTINCT{response_category: tr.response_category,
            age_at_response: tr.age_at_response}) as treatment_response_filters, st, stf, stp            
            RETURN DISTINCT
              su.id as id,
              p.id as pid,
              p.participant_id as participant_id,
              apoc.text.split(p.race, ';') as race,
              p.race as race_str,
              p.sex_at_birth as sex_at_birth,
              apoc.text.join(Collect(distinct sy.synonym_id), ',') as alternate_participant_id,
              su.last_known_survival_status as last_known_survival_status,
              su.age_at_last_known_survival_status as age_at_last_known_survival_status,
              su.event_free_survival_status as event_free_survival_status,
              su.first_event as first_event,
              treatment_filters as treatment_filters,
              treatment_response_filters as treatment_response_filters,
              sample_diagnosis_file_filter AS sample_diagnosis_file_filters,
              st.study_id as study_id,
              st.dbgap_accession as dbgap_accession,
              st.study_status AS study_status,
              st.study_acronym as study_acronym,
              st.study_name as study_name

  - index_name: treatments
    type: neo4j
    mapping:
      id:
        type: keyword
      pid:
        type: keyword
      participant_id:
        type: keyword
        normalizer: lowercase
      race:
        type: keyword
      sex_at_birth:
        type: keyword
      survival_filters:
        type: nested
        properties:
          last_known_survival_status:
            type: keyword
          age_at_last_known_survival_status:
            type: integer
          event_free_survival_status:
            type: keyword
          first_event:
            type: keyword
      treatment_type:
        type: keyword
      treatment_agent:
        type: keyword
      age_at_treatment_start:
        type: integer
      treatment_response_filters:
        type: nested
        properties:
          response_category:
            type: keyword
          age_at_response:
            type: integer
      sample_diagnosis_file_filters:
        type: nested
        properties:
          sample_anatomic_site:
            type: keyword
          participant_age_at_collection:
            type: integer
          sample_tumor_status:
            type: keyword
          tumor_classification:
            type: keyword
          age_at_diagnosis:
            type: integer
          diagnosis_anatomic_site:
            type: keyword
          disease_phase:
            type: keyword
          diagnosis_classification_system:
            type: keyword
          diagnosis_basis:
            type: keyword
          tumor_grade_source:
            type: keyword  
          tumor_stage_source:
            type: keyword              
          diagnosis:
            type: keyword
          diagnosis_category:
            type: keyword
          data_category:
            type: keyword
          file_type:
            type: keyword
          file_mapping_level:
            type: keyword
          library_selection:
            type: keyword
          library_source_material:
            type: keyword
          library_source_molecule:
            type: keyword
          library_strategy:
            type: keyword
      study_id:
        type: keyword
      dbgap_accession:
        type: keyword
      study_status:
        type: keyword
      study_acronym:
        type: keyword
      study_name:
        type: keyword
    # Cypher query will be used to retrieve data from Neo4j, and index into Elasticsearch
    cypher_queries:
      - query: |
          MATCH (p:participant)
          optional match (p)<--(sm:sample)
          optional match (p)<--(file)
          where (file: clinical_measure_file or file: generic_file or file: radiology_file)
          with distinct p, sm, file
          with p, collect(DISTINCT {
                      sample_anatomic_site: apoc.text.split(sm.anatomic_site, ';'),
                      participant_age_at_collection: sm.participant_age_at_collection,
                      sample_tumor_status: sm.sample_tumor_status,
                      tumor_classification: sm.tumor_classification,
                      data_category: apoc.text.split(file.data_category, ';'),
                      file_type: file.file_type,
                      file_mapping_level: file.file_mapping_level,
                      library_source_material: null,
                      library_source_molecule: null,
                      library_strategy: null
              }) as sample_clinical_radiology_file_filter
          optional match (p)<--(sm:sample)<--(file)
          where (file: sequencing_file or file: generic_file or file: methylation_array_file or file: pathology_file or file: cytogenomic_file)
          with p, sample_clinical_radiology_file_filter, collect(DISTINCT {
                      sample_anatomic_site: apoc.text.split(sm.anatomic_site, ';'),
                      participant_age_at_collection: sm.participant_age_at_collection,
                      sample_tumor_status: sm.sample_tumor_status,
                      tumor_classification: sm.tumor_classification,
                      data_category: apoc.text.split(file.data_category, ';'),
                      file_type: file.file_type,
                      file_mapping_level: file.file_mapping_level,
                      library_selection: CASE LABELS(file)[0]
                                    WHEN 'sequencing_file' THEN file.library_selection
                                    ELSE null END,
                      library_source_material: CASE LABELS(file)[0]
                                    WHEN 'sequencing_file' THEN file.library_source_material
                                    ELSE null END,
                      library_source_molecule: CASE LABELS(file)[0]
                                    WHEN 'sequencing_file' THEN file.library_source_molecule
                                    ELSE null END,
                      library_strategy: CASE LABELS(file)[0]
                                    WHEN 'sequencing_file' THEN file.library_strategy
                                    ELSE null END
              }) as sample_sequencing_cytogenomic_pathology_methylation_file_filter
            with p, apoc.coll.union(sample_clinical_radiology_file_filter, sample_sequencing_cytogenomic_pathology_methylation_file_filter) as sample_file_filters
            optional match (p)<--(dg:diagnosis)
            with p, sample_file_filters, dg
            unwind sample_file_filters as sample_file_filter
            with p, collect(apoc.map.merge(sample_file_filter, {
                age_at_diagnosis: dg.age_at_diagnosis,
                diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                disease_phase: dg.disease_phase,
                diagnosis_classification_system: dg.diagnosis_classification_system,
                diagnosis_category: apoc.text.split(dg.diagnosis_category, ';'),
                diagnosis_basis: dg.diagnosis_basis, 
                tumor_grade_source: dg.tumor_grade_source,
                tumor_stage_source: dg.tumor_stage_source,          
                diagnosis: dg.diagnosis
              })) as sample_diagnosis_file_filter
            optional match (p)<--(sm:sample)<--(dg:diagnosis)
            optional match (sm)<--(file)
            where (file: sequencing_file or file: generic_file or file: methylation_array_file or file: pathology_file or file: cytogenomic_file)
            with p, sample_diagnosis_file_filter, COLLECT(DISTINCT {
                    sample_anatomic_site: apoc.text.split(sm.anatomic_site, ';'),
                    participant_age_at_collection: sm.participant_age_at_collection,
                    sample_tumor_status: sm.sample_tumor_status,
                    tumor_classification: sm.tumor_classification,
                    age_at_diagnosis: dg.age_at_diagnosis,
                    diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                    disease_phase: dg.disease_phase,
                    diagnosis_classification_system: dg.diagnosis_classification_system,
                    diagnosis_category: apoc.text.split(dg.diagnosis_category, ';'),
                    diagnosis_basis: dg.diagnosis_basis, 
                    tumor_grade_source: dg.tumor_grade_source,
                    tumor_stage_source: dg.tumor_stage_source,          
                    diagnosis: dg.diagnosis,
                    data_category: apoc.text.split(file.data_category, ';'),
                    file_type: file.file_type,
                    file_mapping_level: file.file_mapping_level,
                    library_selection: CASE LABELS(file)[0]
                              WHEN 'sequencing_file' THEN file.library_selection
                              ELSE null END,
                    library_source_material: CASE LABELS(file)[0]
                                    WHEN 'sequencing_file' THEN file.library_source_material
                                    ELSE null END,
                    library_source_molecule: CASE LABELS(file)[0]
                                    WHEN 'sequencing_file' THEN file.library_source_molecule
                                    ELSE null END,
                    library_strategy: CASE LABELS(file)[0]
                              WHEN 'sequencing_file' THEN file.library_strategy
                              ELSE null END
                }) AS sample_diagnosis_filters_1
            with p, apoc.coll.union(sample_diagnosis_file_filter, sample_diagnosis_filters_1) as sample_diagnosis_file_filters
            optional match (p)<--(sm:sample)<--(dg:diagnosis)
            optional match (p)<--(file)
            where (file: clinical_measure_file or file: generic_file or file: radiology_file)
            with p, sample_diagnosis_file_filters, COLLECT(DISTINCT {
                    sample_anatomic_site: apoc.text.split(sm.anatomic_site, ';'),
                    participant_age_at_collection: sm.participant_age_at_collection,
                    sample_tumor_status: sm.sample_tumor_status,
                    tumor_classification: sm.tumor_classification,
                    age_at_diagnosis: dg.age_at_diagnosis,
                    diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                    disease_phase: dg.disease_phase,
                    diagnosis_classification_system: dg.diagnosis_classification_system,
                    diagnosis_category: apoc.text.split(dg.diagnosis_category, ';'),
                    diagnosis_basis: dg.diagnosis_basis, 
                    tumor_grade_source: dg.tumor_grade_source,
                    tumor_stage_source: dg.tumor_stage_source,          
                    diagnosis: dg.diagnosis,
                    data_category: apoc.text.split(file.data_category, ';'),
                    file_type: file.file_type,
                    file_mapping_level: file.file_mapping_level,
                    library_selection: null,
                    library_source_material: null,
                    library_source_molecule: null,
                    library_strategy: null
                }) AS sample_diagnosis_filters_2
            with p, apoc.coll.union(sample_diagnosis_file_filters, sample_diagnosis_filters_2) as sample_diagnosis_file_filter
          optional MATCH (p)<-[:of_sample]-(sm1:sample)<--(cl)<--(sm2:sample)
          WHERE (cl: cell_line or cl: pdx)
          optional Match (sm2)<--(file)
          WHERE (file: sequencing_file or file: generic_file OR file:pathology_file OR file:methylation_array_file OR file:cytogenomic_file)
          optional Match (sm1)<--(dg:diagnosis)
          with p, sample_diagnosis_file_filter, COLLECT(DISTINCT {
                    sample_anatomic_site: apoc.text.split(sm1.anatomic_site, ';'),
                    participant_age_at_collection: sm1.participant_age_at_collection,
                    sample_tumor_status: sm1.sample_tumor_status,
                    tumor_classification: sm1.tumor_classification,
                    age_at_diagnosis: dg.age_at_diagnosis,
                    diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                    disease_phase: dg.disease_phase,
                    diagnosis_classification_system: dg.diagnosis_classification_system,
                    diagnosis_category: apoc.text.split(dg.diagnosis_category, ';'),
                    diagnosis_basis: dg.diagnosis_basis, 
                    tumor_grade_source: dg.tumor_grade_source,
                    tumor_stage_source: dg.tumor_stage_source,          
                    diagnosis: dg.diagnosis,
                    data_category: apoc.text.split(file.data_category, ';'),
                    file_type: file.file_type,
                    file_mapping_level: file.file_mapping_level,
                    library_selection: CASE LABELS(file)[0]
                              WHEN 'sequencing_file' THEN file.library_selection
                              ELSE null END,
                    library_source_material: CASE LABELS(file)[0]
                                    WHEN 'sequencing_file' THEN file.library_source_material
                                    ELSE null END,
                    library_source_molecule: CASE LABELS(file)[0]
                                    WHEN 'sequencing_file' THEN file.library_source_molecule
                                    ELSE null END,
                    library_strategy: CASE LABELS(file)[0]
                              WHEN 'sequencing_file' THEN file.library_strategy
                              ELSE null END
                }) AS sample_diagnosis_filters_1
            with p, apoc.coll.union(sample_diagnosis_file_filter, sample_diagnosis_filters_1) as sample_diagnosis_file_filters
          optional MATCH (p)<-[:of_sample]-(sm1:sample)<--(cl)<--(sm2:sample)
          WHERE (cl: cell_line or cl: pdx)
          optional Match (sm2)<--(file)
          WHERE (file: sequencing_file or file: generic_file OR file:pathology_file OR file:methylation_array_file OR file:cytogenomic_file)
          optional Match (sm2)<--(dg:diagnosis)
          with p, sample_diagnosis_file_filters, COLLECT(DISTINCT {
                    sample_anatomic_site: apoc.text.split(sm2.anatomic_site, ';'),
                    participant_age_at_collection: sm2.participant_age_at_collection,
                    sample_tumor_status: sm2.sample_tumor_status,
                    tumor_classification: sm2.tumor_classification,
                    age_at_diagnosis: dg.age_at_diagnosis,
                    diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                    disease_phase: dg.disease_phase,
                    diagnosis_classification_system: dg.diagnosis_classification_system,
                    diagnosis_category: apoc.text.split(dg.diagnosis_category, ';'),
                    diagnosis_basis: dg.diagnosis_basis, 
                    tumor_grade_source: dg.tumor_grade_source,
                    tumor_stage_source: dg.tumor_stage_source,          
                    diagnosis: dg.diagnosis,
                    data_category: apoc.text.split(file.data_category, ';'),
                    file_type: file.file_type,
                    file_mapping_level: file.file_mapping_level,
                    library_selection: CASE LABELS(file)[0]
                              WHEN 'sequencing_file' THEN file.library_selection
                              ELSE null END,
                    library_source_material: CASE LABELS(file)[0]
                                    WHEN 'sequencing_file' THEN file.library_source_material
                                    ELSE null END,
                    library_source_molecule: CASE LABELS(file)[0]
                                    WHEN 'sequencing_file' THEN file.library_source_molecule
                                    ELSE null END,
                    library_strategy: CASE LABELS(file)[0]
                              WHEN 'sequencing_file' THEN file.library_strategy
                              ELSE null END
                }) AS sample_diagnosis_filters_2
            with p, apoc.coll.union(sample_diagnosis_file_filters, sample_diagnosis_filters_2) as sample_diagnosis_file_filter
          optional MATCH (p)<-[:of_sample]-(sm1:sample)<--(cl)<--(sm2:sample)
          WHERE (cl: cell_line or cl: pdx)
          optional Match (sm1)<--(dg:diagnosis)
          optional match (p)<--(file)
          where (file: clinical_measure_file or file: generic_file or file: radiology_file)
          with p, sample_diagnosis_file_filter, COLLECT(DISTINCT {
                    sample_anatomic_site: apoc.text.split(sm1.anatomic_site, ';'),
                    participant_age_at_collection: sm1.participant_age_at_collection,
                    sample_tumor_status: sm1.sample_tumor_status,
                    tumor_classification: sm1.tumor_classification,
                    age_at_diagnosis: dg.age_at_diagnosis,
                    diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                    disease_phase: dg.disease_phase,
                    diagnosis_classification_system: dg.diagnosis_classification_system,
                    diagnosis_category: apoc.text.split(dg.diagnosis_category, ';'),
                    diagnosis_basis: dg.diagnosis_basis, 
                    tumor_grade_source: dg.tumor_grade_source,
                    tumor_stage_source: dg.tumor_stage_source,          
                    diagnosis: dg.diagnosis,
                    data_category: apoc.text.split(file.data_category, ';'),
                    file_type: file.file_type,
                    file_mapping_level: file.file_mapping_level,
                    library_selection: null,
                    library_source_material: null,
                    library_source_molecule: null,
                    library_strategy: null
                }) AS sample_diagnosis_filters_3
            with p, apoc.coll.union(sample_diagnosis_file_filter, sample_diagnosis_filters_3) as sample_diagnosis_file_filters
          optional MATCH (p)<-[:of_sample]-(sm1:sample)<--(cl)<--(sm2:sample)
          WHERE (cl: cell_line or cl: pdx)
          optional Match (sm2)<--(dg:diagnosis)
          optional match (p)<--(file)
          where (file: clinical_measure_file or file: generic_file or file: radiology_file)
          with p, sample_diagnosis_file_filters, COLLECT(DISTINCT {
                    sample_anatomic_site: apoc.text.split(sm2.anatomic_site, ';'),
                    participant_age_at_collection: sm2.participant_age_at_collection,
                    sample_tumor_status: sm2.sample_tumor_status,
                    tumor_classification: sm2.tumor_classification,
                    age_at_diagnosis: dg.age_at_diagnosis,
                    diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                    disease_phase: dg.disease_phase,
                    diagnosis_classification_system: dg.diagnosis_classification_system,
                    diagnosis_category: apoc.text.split(dg.diagnosis_category, ';'),
                    diagnosis_basis: dg.diagnosis_basis, 
                    tumor_grade_source: dg.tumor_grade_source,
                    tumor_stage_source: dg.tumor_stage_source,          
                    diagnosis: dg.diagnosis,
                    data_category: apoc.text.split(file.data_category, ';'),
                    file_type: file.file_type,
                    file_mapping_level: file.file_mapping_level,
                    library_selection: null,
                    library_source_material: null,
                    library_source_molecule: null,
                    library_strategy: null
                }) AS sample_diagnosis_filters_4
            with p, apoc.coll.union(sample_diagnosis_file_filters, sample_diagnosis_filters_4) as sample_diagnosis_file_filter
            MATCH (p)<-[:of_treatment]-(tm:treatment)
            OPTIONAL MATCH (p)<-[:of_survival]-(su:survival)
            OPTIONAL MATCH (p)<-[:of_treatment_response]-(tr:treatment_response)
            OPTIONAL MATCH (p)<-[:of_synonym]-(sy:synonym)
            OPTIONAL MATCH (st:study)<-[:of_consent_group]-(cg:consent_group)<-[:of_participant]-(p)
            OPTIONAL MATCH (st)<-[:of_study_personnel]-(stp:study_personnel)
            OPTIONAL MATCH (st)<-[:of_study_funding]-(stf:study_funding)
            WITH tm, p, sy, sample_diagnosis_file_filter,	COLLECT(DISTINCT {last_known_survival_status: su.last_known_survival_status, 
              event_free_survival_status: su.event_free_survival_status, 
              first_event: su.first_event,
              age_at_last_known_survival_status: su.age_at_last_known_survival_status} ) AS survival_filters,
            COLLECT(DISTINCT{response_category: tr.response_category,
            age_at_response: tr.age_at_response}) as treatment_response_filters, st, stf, stp            
            RETURN DISTINCT
              tm.id as id,
              p.id as pid,
              p.participant_id as participant_id,
              apoc.text.split(p.race, ';') as race,
              p.race as race_str,
              p.sex_at_birth as sex_at_birth,
              apoc.text.join(Collect(distinct sy.synonym_id), ',') as alternate_participant_id,
              survival_filters as survival_filters,
              apoc.text.split(tm.treatment_type, ';') as treatment_type,
              apoc.text.split(tm.treatment_agent, ';') as treatment_agent,
              tm.age_at_treatment_start as age_at_treatment_start,
              treatment_response_filters as treatment_response_filters,
              sample_diagnosis_file_filter AS sample_diagnosis_file_filters,
              st.study_id as study_id,
              st.dbgap_accession as dbgap_accession,
              st.study_status AS study_status,
              st.study_acronym as study_acronym,
              st.study_name as study_name

  - index_name: treatment_responses
    type: neo4j
    mapping:
      id:
        type: keyword
      pid:
        type: keyword
      participant_id:
        type: keyword
        normalizer: lowercase
      race:
        type: keyword
      sex_at_birth:
        type: keyword
      survival_filters:
        type: nested
        properties:
          last_known_survival_status:
            type: keyword
          age_at_last_known_survival_status:
            type: integer
          event_free_survival_status:
            type: keyword
          first_event:
            type: keyword
      treatment_filters:
        type: nested
        properties:
          treatment_type:
            type: keyword
          treatment_agent:
            type: keyword
          age_at_treatment_start:
            type: integer
      response_category:
        type: keyword
      age_at_response:
        type: integer
      sample_diagnosis_file_filters:
        type: nested
        properties:
          sample_anatomic_site:
            type: keyword
          participant_age_at_collection:
            type: integer
          sample_tumor_status:
            type: keyword
          tumor_classification:
            type: keyword
          age_at_diagnosis:
            type: integer
          diagnosis_anatomic_site:
            type: keyword
          disease_phase:
            type: keyword
          diagnosis_classification_system:
            type: keyword
          diagnosis_basis:
            type: keyword
          tumor_grade_source:
            type: keyword  
          tumor_stage_source:
            type: keyword              
          diagnosis:
            type: keyword
          diagnosis_category:
            type: keyword
          data_category:
            type: keyword
          file_type:
            type: keyword
          file_mapping_level:
            type: keyword
          library_selection:
            type: keyword
          library_source_material:
            type: keyword
          library_source_molecule:
            type: keyword
          library_strategy:
            type: keyword
      study_id:
        type: keyword
      dbgap_accession:
        type: keyword
      study_status:
        type: keyword
      study_acronym:
        type: keyword
      study_name:
        type: keyword
    # Cypher query will be used to retrieve data from Neo4j, and index into Elasticsearch
    cypher_queries:
      - query: |
          MATCH (p:participant)
          optional match (p)<--(sm:sample)
          optional match (p)<--(file)
          where (file: clinical_measure_file or file: generic_file or file: radiology_file)
          with distinct p, sm, file
          with p, collect(DISTINCT {
                      sample_anatomic_site: apoc.text.split(sm.anatomic_site, ';'),
                      participant_age_at_collection: sm.participant_age_at_collection,
                      sample_tumor_status: sm.sample_tumor_status,
                      tumor_classification: sm.tumor_classification,
                      data_category: apoc.text.split(file.data_category, ';'),
                      file_type: file.file_type,
                      file_mapping_level: file.file_mapping_level,
                      library_source_material: null,
                      library_source_molecule: null,
                      library_strategy: null
              }) as sample_clinical_radiology_file_filter
          optional match (p)<--(sm:sample)<--(file)
          where (file: sequencing_file or file: generic_file or file: methylation_array_file or file: pathology_file or file: cytogenomic_file)
          with p, sample_clinical_radiology_file_filter, collect(DISTINCT {
                      sample_anatomic_site: apoc.text.split(sm.anatomic_site, ';'),
                      participant_age_at_collection: sm.participant_age_at_collection,
                      sample_tumor_status: sm.sample_tumor_status,
                      tumor_classification: sm.tumor_classification,
                      data_category: apoc.text.split(file.data_category, ';'),
                      file_type: file.file_type,
                      file_mapping_level: file.file_mapping_level,
                      library_selection: CASE LABELS(file)[0]
                                    WHEN 'sequencing_file' THEN file.library_selection
                                    ELSE null END,
                      library_source_material: CASE LABELS(file)[0]
                                    WHEN 'sequencing_file' THEN file.library_source_material
                                    ELSE null END,
                      library_source_molecule: CASE LABELS(file)[0]
                                    WHEN 'sequencing_file' THEN file.library_source_molecule
                                    ELSE null END,
                      library_strategy: CASE LABELS(file)[0]
                                    WHEN 'sequencing_file' THEN file.library_strategy
                                    ELSE null END
              }) as sample_sequencing_cytogenomic_pathology_methylation_file_filter
            with p, apoc.coll.union(sample_clinical_radiology_file_filter, sample_sequencing_cytogenomic_pathology_methylation_file_filter) as sample_file_filters
            optional match (p)<--(dg:diagnosis)
            with p, sample_file_filters, dg
            unwind sample_file_filters as sample_file_filter
            with p, collect(apoc.map.merge(sample_file_filter, {
                age_at_diagnosis: dg.age_at_diagnosis,
                diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                disease_phase: dg.disease_phase,
                diagnosis_classification_system: dg.diagnosis_classification_system,
                diagnosis_category: apoc.text.split(dg.diagnosis_category, ';'),
                diagnosis_basis: dg.diagnosis_basis, 
                tumor_grade_source: dg.tumor_grade_source,
                tumor_stage_source: dg.tumor_stage_source,          
                diagnosis: dg.diagnosis
              })) as sample_diagnosis_file_filter
            optional match (p)<--(sm:sample)<--(dg:diagnosis)
            optional match (sm)<--(file)
            where (file: sequencing_file or file: generic_file or file: methylation_array_file or file: pathology_file or file: cytogenomic_file)
            with p, sample_diagnosis_file_filter, COLLECT(DISTINCT {
                    sample_anatomic_site: apoc.text.split(sm.anatomic_site, ';'),
                    participant_age_at_collection: sm.participant_age_at_collection,
                    sample_tumor_status: sm.sample_tumor_status,
                    tumor_classification: sm.tumor_classification,
                    age_at_diagnosis: dg.age_at_diagnosis,
                    diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                    disease_phase: dg.disease_phase,
                    diagnosis_classification_system: dg.diagnosis_classification_system,
                    diagnosis_category: apoc.text.split(dg.diagnosis_category, ';'),
                    diagnosis_basis: dg.diagnosis_basis, 
                    tumor_grade_source: dg.tumor_grade_source,
                    tumor_stage_source: dg.tumor_stage_source,          
                    diagnosis: dg.diagnosis,
                    data_category: apoc.text.split(file.data_category, ';'),
                    file_type: file.file_type,
                    file_mapping_level: file.file_mapping_level,
                    library_selection: CASE LABELS(file)[0]
                              WHEN 'sequencing_file' THEN file.library_selection
                              ELSE null END,
                    library_source_material: CASE LABELS(file)[0]
                                    WHEN 'sequencing_file' THEN file.library_source_material
                                    ELSE null END,
                    library_source_molecule: CASE LABELS(file)[0]
                                    WHEN 'sequencing_file' THEN file.library_source_molecule
                                    ELSE null END,
                    library_strategy: CASE LABELS(file)[0]
                              WHEN 'sequencing_file' THEN file.library_strategy
                              ELSE null END
                }) AS sample_diagnosis_filters_1
            with p, apoc.coll.union(sample_diagnosis_file_filter, sample_diagnosis_filters_1) as sample_diagnosis_file_filters
            optional match (p)<--(sm:sample)<--(dg:diagnosis)
            optional match (p)<--(file)
            where (file: clinical_measure_file or file: generic_file or file: radiology_file)
            with p, sample_diagnosis_file_filters, COLLECT(DISTINCT {
                    sample_anatomic_site: apoc.text.split(sm.anatomic_site, ';'),
                    participant_age_at_collection: sm.participant_age_at_collection,
                    sample_tumor_status: sm.sample_tumor_status,
                    tumor_classification: sm.tumor_classification,
                    age_at_diagnosis: dg.age_at_diagnosis,
                    diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                    disease_phase: dg.disease_phase,
                    diagnosis_classification_system: dg.diagnosis_classification_system,
                    diagnosis_category: apoc.text.split(dg.diagnosis_category, ';'),
                    diagnosis_basis: dg.diagnosis_basis, 
                    tumor_grade_source: dg.tumor_grade_source,
                    tumor_stage_source: dg.tumor_stage_source,          
                    diagnosis: dg.diagnosis,
                    data_category: apoc.text.split(file.data_category, ';'),
                    file_type: file.file_type,
                    file_mapping_level: file.file_mapping_level,
                    library_selection: null,
                    library_source_material: null,
                    library_source_molecule: null,
                    library_strategy: null
                }) AS sample_diagnosis_filters_2
            with p, apoc.coll.union(sample_diagnosis_file_filters, sample_diagnosis_filters_2) as sample_diagnosis_file_filter
          optional MATCH (p)<-[:of_sample]-(sm1:sample)<--(cl)<--(sm2:sample)
          WHERE (cl: cell_line or cl: pdx)
          optional Match (sm2)<--(file)
          WHERE (file: sequencing_file or file: generic_file OR file:pathology_file OR file:methylation_array_file OR file:cytogenomic_file)
          optional Match (sm1)<--(dg:diagnosis)
          with p, sample_diagnosis_file_filter, COLLECT(DISTINCT {
                    sample_anatomic_site: apoc.text.split(sm1.anatomic_site, ';'),
                    participant_age_at_collection: sm1.participant_age_at_collection,
                    sample_tumor_status: sm1.sample_tumor_status,
                    tumor_classification: sm1.tumor_classification,
                    age_at_diagnosis: dg.age_at_diagnosis,
                    diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                    disease_phase: dg.disease_phase,
                    diagnosis_classification_system: dg.diagnosis_classification_system,
                    diagnosis_category: apoc.text.split(dg.diagnosis_category, ';'),
                    diagnosis_basis: dg.diagnosis_basis, 
                    tumor_grade_source: dg.tumor_grade_source,
                    tumor_stage_source: dg.tumor_stage_source,          
                    diagnosis: dg.diagnosis,
                    data_category: apoc.text.split(file.data_category, ';'),
                    file_type: file.file_type,
                    file_mapping_level: file.file_mapping_level,
                    library_selection: CASE LABELS(file)[0]
                              WHEN 'sequencing_file' THEN file.library_selection
                              ELSE null END,
                    library_source_material: CASE LABELS(file)[0]
                                    WHEN 'sequencing_file' THEN file.library_source_material
                                    ELSE null END,
                    library_source_molecule: CASE LABELS(file)[0]
                                    WHEN 'sequencing_file' THEN file.library_source_molecule
                                    ELSE null END,
                    library_strategy: CASE LABELS(file)[0]
                              WHEN 'sequencing_file' THEN file.library_strategy
                              ELSE null END
                }) AS sample_diagnosis_filters_1
            with p, apoc.coll.union(sample_diagnosis_file_filter, sample_diagnosis_filters_1) as sample_diagnosis_file_filters
          optional MATCH (p)<-[:of_sample]-(sm1:sample)<--(cl)<--(sm2:sample)
          WHERE (cl: cell_line or cl: pdx)
          optional Match (sm2)<--(file)
          WHERE (file: sequencing_file or file: generic_file OR file:pathology_file OR file:methylation_array_file OR file:cytogenomic_file)
          optional Match (sm2)<--(dg:diagnosis)
          with p, sample_diagnosis_file_filters, COLLECT(DISTINCT {
                    sample_anatomic_site: apoc.text.split(sm2.anatomic_site, ';'),
                    participant_age_at_collection: sm2.participant_age_at_collection,
                    sample_tumor_status: sm2.sample_tumor_status,
                    tumor_classification: sm2.tumor_classification,
                    age_at_diagnosis: dg.age_at_diagnosis,
                    diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                    disease_phase: dg.disease_phase,
                    diagnosis_classification_system: dg.diagnosis_classification_system,
                    diagnosis_category: apoc.text.split(dg.diagnosis_category, ';'),
                    diagnosis_basis: dg.diagnosis_basis, 
                    tumor_grade_source: dg.tumor_grade_source,
                    tumor_stage_source: dg.tumor_stage_source,          
                    diagnosis: dg.diagnosis,
                    data_category: apoc.text.split(file.data_category, ';'),
                    file_type: file.file_type,
                    library_selection: CASE LABELS(file)[0]
                              WHEN 'sequencing_file' THEN file.library_selection
                              ELSE null END,
                    library_source_material: CASE LABELS(file)[0]
                                    WHEN 'sequencing_file' THEN file.library_source_material
                                    ELSE null END,
                    library_source_molecule: CASE LABELS(file)[0]
                                    WHEN 'sequencing_file' THEN file.library_source_molecule
                                    ELSE null END,
                    library_strategy: CASE LABELS(file)[0]
                              WHEN 'sequencing_file' THEN file.library_strategy
                              ELSE null END
                }) AS sample_diagnosis_filters_2
            with p, apoc.coll.union(sample_diagnosis_file_filters, sample_diagnosis_filters_2) as sample_diagnosis_file_filter
          optional MATCH (p)<-[:of_sample]-(sm1:sample)<--(cl)<--(sm2:sample)
          WHERE (cl: cell_line or cl: pdx)
          optional Match (sm1)<--(dg:diagnosis)
          optional match (p)<--(file)
          where (file: clinical_measure_file or file: generic_file or file: radiology_file)
          with p, sample_diagnosis_file_filter, COLLECT(DISTINCT {
                    sample_anatomic_site: apoc.text.split(sm1.anatomic_site, ';'),
                    participant_age_at_collection: sm1.participant_age_at_collection,
                    sample_tumor_status: sm1.sample_tumor_status,
                    tumor_classification: sm1.tumor_classification,
                    age_at_diagnosis: dg.age_at_diagnosis,
                    diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                    disease_phase: dg.disease_phase,
                    diagnosis_classification_system: dg.diagnosis_classification_system,
                    diagnosis_category: apoc.text.split(dg.diagnosis_category, ';'),
                    diagnosis_basis: dg.diagnosis_basis, 
                    tumor_grade_source: dg.tumor_grade_source,
                    tumor_stage_source: dg.tumor_stage_source,          
                    diagnosis: dg.diagnosis,
                    data_category: apoc.text.split(file.data_category, ';'),
                    file_type: file.file_type,
                    file_mapping_level: file.file_mapping_level,
                    library_selection: null,
                    library_source_material: null,
                    library_source_molecule: null,
                    library_strategy: null
                }) AS sample_diagnosis_filters_3
            with p, apoc.coll.union(sample_diagnosis_file_filter, sample_diagnosis_filters_3) as sample_diagnosis_file_filters
          optional MATCH (p)<-[:of_sample]-(sm1:sample)<--(cl)<--(sm2:sample)
          WHERE (cl: cell_line or cl: pdx)
          optional Match (sm2)<--(dg:diagnosis)
          optional match (p)<--(file)
          where (file: clinical_measure_file or file: generic_file or file: radiology_file)
          with p, sample_diagnosis_file_filters, COLLECT(DISTINCT {
                    sample_anatomic_site: apoc.text.split(sm2.anatomic_site, ';'),
                    participant_age_at_collection: sm2.participant_age_at_collection,
                    sample_tumor_status: sm2.sample_tumor_status,
                    tumor_classification: sm2.tumor_classification,
                    age_at_diagnosis: dg.age_at_diagnosis,
                    diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                    disease_phase: dg.disease_phase,
                    diagnosis_classification_system: dg.diagnosis_classification_system,
                    diagnosis_category: apoc.text.split(dg.diagnosis_category, ';'),
                    diagnosis_basis: dg.diagnosis_basis, 
                    tumor_grade_source: dg.tumor_grade_source,
                    tumor_stage_source: dg.tumor_stage_source,          
                    diagnosis: dg.diagnosis,
                    data_category: apoc.text.split(file.data_category, ';'),
                    file_type: file.file_type,
                    file_mapping_level: file.file_mapping_level,
                    library_selection: null,
                    library_source_material: null,
                    library_source_molecule: null,
                    library_strategy: null
                }) AS sample_diagnosis_filters_4
            with p, apoc.coll.union(sample_diagnosis_file_filters, sample_diagnosis_filters_4) as sample_diagnosis_file_filter
            MATCH (p)<-[:of_treatment_response]-(tr:treatment_response)
            OPTIONAL MATCH (p)<-[:of_survival]-(su:survival)
            OPTIONAL MATCH (p)<-[:of_treatment]-(tm:treatment)
            OPTIONAL MATCH (p)<-[:of_synonym]-(sy:synonym)
            OPTIONAL MATCH (st:study)<-[:of_consent_group]-(cg:consent_group)<-[:of_participant]-(p)
            OPTIONAL MATCH (st)<-[:of_study_personnel]-(stp:study_personnel)
            OPTIONAL MATCH (st)<-[:of_study_funding]-(stf:study_funding)
            WITH tr, p, sy, sample_diagnosis_file_filter,	COLLECT(DISTINCT {last_known_survival_status: su.last_known_survival_status, 
              event_free_survival_status: su.event_free_survival_status, 
              first_event: su.first_event,
              age_at_last_known_survival_status: su.age_at_last_known_survival_status} ) AS survival_filters,
              COLLECT(DISTINCT{treatment_type: apoc.text.split(tm.treatment_type, ';'),
            treatment_agent: apoc.text.split(tm.treatment_agent, ';'),
            age_at_treatment_start: tm.age_at_treatment_start}) as treatment_filters, st, stf, stp            
            RETURN DISTINCT
              tr.id as id,
              p.id as pid,
              p.participant_id as participant_id,
              apoc.text.split(p.race, ';') as race,
              p.race as race_str,
              p.sex_at_birth as sex_at_birth,
              apoc.text.join(Collect(distinct sy.synonym_id), ',') as alternate_participant_id,
              survival_filters as survival_filters,
              tr.response_category as response_category,
              tr.age_at_response as age_at_response,
              treatment_filters as treatment_filters,
              sample_diagnosis_file_filter AS sample_diagnosis_file_filters,
              st.study_id as study_id,
              st.dbgap_accession as dbgap_accession,
              st.study_status AS study_status,
              st.study_acronym as study_acronym,
              st.study_name as study_name

  - index_name: diagnosis
    type: neo4j
    mapping:
      id:
        type: keyword
      pid:
        type: keyword
      diagnosis_id:
        type: keyword
      participant_id:
        type: keyword
      sid:
        type: keyword
      sample_id:
        type: keyword
      diagnosis:
        type: keyword
      diagnosis_category:
        type: keyword
      diagnosis_category_str:
        type: keyword
      disease_phase:
        type: keyword
      diagnosis_classification_system:
        type: keyword
      diagnosis_basis:
        type: keyword
      tumor_grade_source:
        type: keyword  
      tumor_stage_source:
        type: keyword    
      diagnosis_anatomic_site:
        type: keyword
      diagnosis_anatomic_site_str:
        type: keyword
      age_at_diagnosis:
        type: integer
      race:
        type: keyword
      sex_at_birth:
        type: keyword
      dbgap_accession:
        type: keyword
      study_status:
        type: keyword
      study_id:
        type: keyword
      study_acronym:
        type: keyword
      study_name:
        type: keyword
      survival_filters:
        type: nested
        properties:
          last_known_survival_status:
            type: keyword
          age_at_last_known_survival_status:
            type: integer
          event_free_survival_status:
            type: keyword
          first_event:
            type: keyword
      treatment_filters:
        type: nested
        properties:
          treatment_type:
            type: keyword
          treatment_agent:
            type: keyword
          age_at_treatment_start:
            type: integer
      treatment_response_filters:
        type: nested
        properties:
          response_category:
            type: keyword
          age_at_response:
            type: integer
      sample_file_filters:
        type: nested
        properties:
          sample_anatomic_site:
            type: keyword
          participant_age_at_collection:
            type: integer
          sample_tumor_status:
            type: keyword
          tumor_classification:
            type: keyword
          data_category:
            type: keyword
          file_type:
            type: keyword
          file_mapping_level:
            type: keyword
          library_selection:
            type: keyword
          library_source_material:
            type: keyword
          library_source_molecule:
            type: keyword
          library_strategy:
            type: keyword
      file_count:
        type: integer
      files:
        type: text
        fields:
          keyword:
            type: keyword
    # Cypher query will be used to retrieve data from Neo4j, and index into Elasticsearch
    cypher_queries:
      - query: |
          Match (p:participant)<--(:diagnosis)
          WITH distinct p, {
            pid: p.id,
            participant_id: p.participant_id,
            race: apoc.text.split(p.race, ';'),
            sex_at_birth: p.sex_at_birth
          } AS opensearch_data
          SKIP $skip LIMIT $limit
          optional MATCH (p)<-[:of_sample]-(sm1:sample)<--(cl)<--(sm2:sample)
          WHERE (cl: cell_line or cl: pdx)
          optional Match (sm2)<--(file)
          WHERE (file: sequencing_file or file: generic_file OR file:pathology_file OR file:methylation_array_file OR file:cytogenomic_file)
          with p, opensearch_data, case COLLECT(distinct sm1) when [] then []
                        else COLLECT(DISTINCT {
                                sample_anatomic_site: apoc.text.split(sm1.anatomic_site, ';'),
                                participant_age_at_collection: sm1.participant_age_at_collection,
                                sample_tumor_status: sm1.sample_tumor_status,
                                tumor_classification: sm1.tumor_classification,
                                data_category: apoc.text.split(file.data_category, ';'),
                                file_type: CASE LABELS(file)[0]
                                          When null then null
                                          else file.file_type end,
                                file_mapping_level: file.file_mapping_level,
                                library_selection: CASE LABELS(file)[0]
                                              WHEN 'sequencing_file' THEN file.library_selection
                                              ELSE null END,
                                library_source_material: CASE LABELS(file)[0]
                                            WHEN 'sequencing_file' THEN file.library_source_material
                                            ELSE null END,
                                library_source_molecule: CASE LABELS(file)[0]
                                            WHEN 'sequencing_file' THEN file.library_source_molecule
                                            ELSE null END,
                                library_strategy: CASE LABELS(file)[0]
                                              WHEN 'sequencing_file' THEN file.library_strategy
                                              ELSE null END
                            }) end AS sample1,
                            case COLLECT(distinct sm2)
                            when [] then []
                            else COLLECT(DISTINCT {
                                sample_anatomic_site: apoc.text.split(sm2.anatomic_site, ';'),
                                participant_age_at_collection: sm2.participant_age_at_collection,
                                sample_tumor_status: sm2.sample_tumor_status,
                                tumor_classification: sm2.tumor_classification,
                                data_category: apoc.text.split(file.data_category, ';'),
                                file_type: CASE LABELS(file)[0]
                                          When null then null
                                          else file.file_type end,
                                file_mapping_level: file.file_mapping_level,
                                library_selection: CASE LABELS(file)[0]
                                              WHEN 'sequencing_file' THEN file.library_selection
                                              ELSE null END,
                                library_source_material: CASE LABELS(file)[0]
                                            WHEN 'sequencing_file' THEN file.library_source_material
                                            ELSE null END,
                                library_source_molecule: CASE LABELS(file)[0]
                                            WHEN 'sequencing_file' THEN file.library_source_molecule
                                            ELSE null END,
                                library_strategy: CASE LABELS(file)[0]
                                              WHEN 'sequencing_file' THEN file.library_strategy
                                              ELSE null END
                            }) end AS sample2
          with p, opensearch_data, apoc.coll.union(sample1,sample2) as cell_line_pdx_file_filters_1
          optional MATCH (p)<-[:of_sample]-(sm1:sample)<--(cl)<--(sm2:sample)
          WHERE (cl: cell_line or cl: pdx)
          optional Match (sm1)<--(file)
          WHERE (file: sequencing_file or file: generic_file OR file:pathology_file OR file:methylation_array_file OR file:cytogenomic_file)
          with p, opensearch_data, cell_line_pdx_file_filters_1, case COLLECT(distinct sm2) when [] then []
                            else COLLECT(DISTINCT {
                                sample_anatomic_site: apoc.text.split(sm2.anatomic_site, ';'),
                                participant_age_at_collection: sm2.participant_age_at_collection,
                                sample_tumor_status: sm2.sample_tumor_status,
                                tumor_classification: sm2.tumor_classification,
                                data_category: apoc.text.split(file.data_category, ';'),
                                file_type: CASE LABELS(file)[0]
                                          When null then null
                                          else file.file_type end,
                                file_mapping_level: file.file_mapping_level,
                                library_selection: CASE LABELS(file)[0]
                                              WHEN 'sequencing_file' THEN file.library_selection
                                              ELSE null END,
                                library_source_material: CASE LABELS(file)[0]
                                            WHEN 'sequencing_file' THEN file.library_source_material
                                            ELSE null END,
                                library_source_molecule: CASE LABELS(file)[0]
                                            WHEN 'sequencing_file' THEN file.library_source_molecule
                                            ELSE null END,
                                library_strategy: CASE LABELS(file)[0]
                                              WHEN 'sequencing_file' THEN file.library_strategy
                                              ELSE null END
                            }) end AS cell_line_pdx_file_filters_2
          with p, opensearch_data, apoc.coll.union(cell_line_pdx_file_filters_1, cell_line_pdx_file_filters_2) as cell_line_pdx_file_filters
          OPTIONAL MATCH (p)<-[:of_sample]-(sm:sample)
          optional match (sm)<--(file)
          WHERE (file: sequencing_file or file: generic_file OR file:pathology_file OR file:methylation_array_file OR file:cytogenomic_file)
          with p, opensearch_data, cell_line_pdx_file_filters, COLLECT(DISTINCT {
                        sample_anatomic_site: apoc.text.split(sm.anatomic_site, ';'),
                        participant_age_at_collection: sm.participant_age_at_collection,
                        sample_tumor_status: sm.sample_tumor_status,
                        tumor_classification: sm.tumor_classification,
                        data_category: apoc.text.split(file.data_category, ';'),
                        file_type: file.file_type,
                        file_mapping_level: file.file_mapping_level,
                        library_selection: CASE LABELS(file)[0]
                                      WHEN 'sequencing_file' THEN file.library_selection
                                      ELSE null END,
                        library_source_material: CASE LABELS(file)[0]
                                            WHEN 'sequencing_file' THEN file.library_source_material
                                            ELSE null END,
                        library_source_molecule: CASE LABELS(file)[0]
                                            WHEN 'sequencing_file' THEN file.library_source_molecule
                                            ELSE null END,
                        library_strategy: CASE LABELS(file)[0]
                                      WHEN 'sequencing_file' THEN file.library_strategy
                                      ELSE null END
                    }) AS general_file_filters_1
          with p, opensearch_data, apoc.coll.union(cell_line_pdx_file_filters, general_file_filters_1) as general_file_filters
          OPTIONAL Match (p)<-[*..3]-(sm:sample)
          OPTIONAL MATCH (p)<--(file)
          where (file:clinical_measure_file or file: generic_file or file:radiology_file)
          with p, opensearch_data, general_file_filters, case COLLECT(file) when [] then [] else COLLECT(DISTINCT {
                    sample_anatomic_site: apoc.text.split(sm.anatomic_site, ';'),
                    participant_age_at_collection: sm.participant_age_at_collection,
                    sample_tumor_status: sm.sample_tumor_status,
                    tumor_classification: sm.tumor_classification,
                    data_category: apoc.text.split(file.data_category, ';'),
                    file_type: file.file_type,
                    file_mapping_level: file.file_mapping_level,
                    library_selection: null,
                    library_source_material: null,
                    library_source_molecule: null,
                    library_strategy: null
            }) end as participant_file_filters
          optional match (st:study)<--(cg:consent_group)<--(p)<-[*..3]-(sm:sample)
          OPTIONAL MATCH (st)<--(file)
          where (file: clinical_measure_file  or file: generic_file)
          with p, opensearch_data, general_file_filters, participant_file_filters, case COLLECT(file) when [] then [] else COLLECT(DISTINCT {
                    sample_anatomic_site: apoc.text.split(sm.anatomic_site, ';'),
                    participant_age_at_collection: sm.participant_age_at_collection,
                    sample_tumor_status: sm.sample_tumor_status,
                    tumor_classification: sm.tumor_classification,
                    data_category: apoc.text.split(file.data_category, ';'),
                    file_type: file.file_type,
                    file_mapping_level: file.file_mapping_level,
                    library_selection: null,
                    library_source_material: null,
                    library_source_molecule: null,
                    library_strategy: null
            }) end as study_file_filters
          with p, apoc.map.merge(opensearch_data, {
            sample_file_filters: general_file_filters + apoc.coll.union(participant_file_filters, study_file_filters)
          }) AS opensearch_data
          OPTIONAL MATCH (p)<-[:of_survival]-(su:survival)
          with p, apoc.map.merge(opensearch_data, {
            survival_filters: COLLECT(DISTINCT {last_known_survival_status: su.last_known_survival_status,
              event_free_survival_status: su.event_free_survival_status,
              first_event: su.first_event,
              age_at_last_known_survival_status: su.age_at_last_known_survival_status})
          }) AS opensearch_data
          OPTIONAL MATCH (p)<-[:of_treatment]-(tm:treatment)
          with p, apoc.map.merge(opensearch_data, {
            treatment_filters: COLLECT(DISTINCT{treatment_type: apoc.text.split(tm.treatment_type, ';'),
            treatment_agent: apoc.text.split(tm.treatment_agent, ';'),
            age_at_treatment_start: tm.age_at_treatment_start})
          }) AS opensearch_data
          OPTIONAL MATCH (p)<-[:of_treatment_response]-(tr:treatment_response)
          with p, apoc.map.merge(opensearch_data, {
            treatment_response_filters: COLLECT(DISTINCT{response_category: tr.response_category,
            age_at_response: tr.age_at_response})
          }) AS opensearch_data
          OPTIONAL MATCH (p)<-[*..4]-(file)
          WHERE (file:clinical_measure_file or file: generic_file OR file: sequencing_file OR file:pathology_file OR file:radiology_file OR file:methylation_array_file OR file:cytogenomic_file)
          with p, apoc.map.merge(opensearch_data, {
                      file_count: COUNT(DISTINCT file.dcf_indexd_guid),
                      files: COLLECT(DISTINCT file.dcf_indexd_guid)
                    }) AS opensearch_data
          MATCH (dg:diagnosis)
          MATCH (p)<-[:of_diagnosis]-(dg)
          OPTIONAL MATCH (st:study)<-[:of_consent_group]-(cg:consent_group)<-[:of_participant]-(p)
          WITH dg, p, opensearch_data , st
          RETURN DISTINCT
            dg.id as id,
            opensearch_data.pid as pid,
            null as sid,
            null as sample_id,
            dg.diagnosis_id as diagnosis_id,
            dg.diagnosis as diagnosis,
            dg.disease_phase as disease_phase,
            dg.diagnosis_classification_system as diagnosis_classification_system,
            apoc.text.split(dg.diagnosis_category, ';') as diagnosis_category,
            dg.diagnosis_category as diagnosis_category_str,
            dg.diagnosis_basis as diagnosis_basis,
            dg.tumor_grade_source as tumor_grade_source,
            dg.tumor_stage_source as tumor_stage_source,
            apoc.text.split(dg.anatomic_site, ';') as diagnosis_anatomic_site,
            dg.anatomic_site as diagnosis_anatomic_site_str,
            dg.age_at_diagnosis as age_at_diagnosis,
            opensearch_data.participant_id as participant_id,
            opensearch_data.race as race,
            opensearch_data.sex_at_birth as sex_at_birth,
            st.study_id as study_id,
            st.dbgap_accession as dbgap_accession,
            st.study_status AS study_status,
            st.study_acronym as study_acronym,
            st.study_name as study_name,
            opensearch_data.survival_filters as survival_filters, 
            opensearch_data.treatment_filters as treatment_filters,
            opensearch_data.treatment_response_filters as treatment_response_filters,  
            opensearch_data.sample_file_filters AS sample_file_filters,
            opensearch_data.file_count as file_count,
            opensearch_data.files as files
        page_size: 100
      - query: |
          match (st:study)<--(cg:consent_group)<--(p:participant)<--(sm:sample)<--(dg:diagnosis)
          with distinct dg, {
            id: dg.id,
            pid: p.id,
            sid: sm.id,
            sample_id: sm.sample_id,
            diagnosis_id: dg.diagnosis_id,
            diagnosis: dg.diagnosis,
            disease_phase: dg.disease_phase,
            diagnosis_classification_system: dg.diagnosis_classification_system,
            diagnosis_category: apoc.text.split(dg.diagnosis_category, ';'),
            diagnosis_category_str: dg.diagnosis_category,
            diagnosis_basis: dg.diagnosis_basis,
            tumor_grade_source: dg.tumor_grade_source,
            tumor_stage_source: dg.tumor_stage_source,
            diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
            diagnosis_anatomic_site_str: dg.anatomic_site,
            age_at_diagnosis: dg.age_at_diagnosis,
            participant_id: p.participant_id,
            race: apoc.text.split(p.race, ';'),
            sex_at_birth: p.sex_at_birth,
            study_id: st.study_id,
            dbgap_accession: st.dbgap_accession,
            study_status: st.study_status,
            study_acronym: st.study_acronym,
            study_name: st.study_name
          } as opensearch_data
          SKIP $skip LIMIT $limit
          match (p:participant)<--(sm:sample)<--(dg)
          optional match (sm)<-[*..3]-(file)
          where (file: sequencing_file or file: generic_file OR file:pathology_file OR file:methylation_array_file OR file:cytogenomic_file)
          with dg, opensearch_data, COLLECT(DISTINCT {
                    sample_anatomic_site: apoc.text.split(sm.anatomic_site, ';'),
                    participant_age_at_collection: sm.participant_age_at_collection,
                    sample_tumor_status: sm.sample_tumor_status,
                    tumor_classification: sm.tumor_classification,
                    data_category: apoc.text.split(file.data_category, ';'),
                    file_type: file.file_type,
                    file_mapping_level: file.file_mapping_level,
                    library_selection: CASE LABELS(file)[0]
                              WHEN 'sequencing_file' THEN file.library_selection
                              ELSE null END,
                    library_source_material: CASE LABELS(file)[0]
                              WHEN 'sequencing_file' THEN file.library_source_material
                              ELSE null END,
                    library_source_molecule: CASE LABELS(file)[0]
                              WHEN 'sequencing_file' THEN file.library_source_molecule
                              ELSE null END,
                    library_strategy: CASE LABELS(file)[0]
                              WHEN 'sequencing_file' THEN file.library_strategy
                              ELSE null END
            }) as sample_file_filter_1
          match (p:participant)<--(sm1:sample)<--(dg)
          optional match (sm1)<--(cl)<--(sm:sample)
          where (cl: cell_line or cl: pdx)
          optional match (sm)<--(file)
          where (file: sequencing_file or file: generic_file OR file:pathology_file OR file:methylation_array_file OR file:cytogenomic_file)
          with dg, opensearch_data, sample_file_filter_1, COLLECT(DISTINCT {
                    sample_anatomic_site: apoc.text.split(sm.anatomic_site, ';'),
                    participant_age_at_collection: sm.participant_age_at_collection,
                    sample_tumor_status: sm.sample_tumor_status,
                    tumor_classification: sm.tumor_classification,
                    data_category: apoc.text.split(file.data_category, ';'),
                    file_type: file.file_type,
                    file_mapping_level: file.file_mapping_level,
                    library_selection: CASE LABELS(file)[0]
                              WHEN 'sequencing_file' THEN file.library_selection
                              ELSE null END,
                    library_source_material: CASE LABELS(file)[0]
                              WHEN 'sequencing_file' THEN file.library_source_material
                              ELSE null END,
                    library_source_molecule: CASE LABELS(file)[0]
                              WHEN 'sequencing_file' THEN file.library_source_molecule
                              ELSE null END,
                    library_strategy: CASE LABELS(file)[0]
                              WHEN 'sequencing_file' THEN file.library_strategy
                              ELSE null END
            }) as sample_file_filter_2
          with dg, opensearch_data, apoc.coll.union(sample_file_filter_1, sample_file_filter_2) as sample_file_filter
          match (p:participant)<--(sm1:sample)<--(dg)
          optional match (sm1)<--(cl)<--(sm:sample)
          where (cl: cell_line or cl: pdx)
          optional match (sm1)<--(file)
          where (file: sequencing_file or file: generic_file OR file:pathology_file OR file:methylation_array_file OR file:cytogenomic_file)
          with dg, opensearch_data, sample_file_filter, COLLECT(DISTINCT {
                    sample_anatomic_site: apoc.text.split(sm.anatomic_site, ';'),
                    participant_age_at_collection: sm.participant_age_at_collection,
                    sample_tumor_status: sm.sample_tumor_status,
                    tumor_classification: sm.tumor_classification,
                    data_category: apoc.text.split(file.data_category, ';'),
                    file_type: file.file_type,
                    file_mapping_level: file.file_mapping_level,
                    library_selection: CASE LABELS(file)[0]
                              WHEN 'sequencing_file' THEN file.library_selection
                              ELSE null END,
                    library_source_material: CASE LABELS(file)[0]
                              WHEN 'sequencing_file' THEN file.library_source_material
                              ELSE null END,
                    library_source_molecule: CASE LABELS(file)[0]
                              WHEN 'sequencing_file' THEN file.library_source_molecule
                              ELSE null END,
                    library_strategy: CASE LABELS(file)[0]
                              WHEN 'sequencing_file' THEN file.library_strategy
                              ELSE null END
            }) as sample_file_filter_3
          with dg, opensearch_data, apoc.coll.union(sample_file_filter, sample_file_filter_3) as sample_file_filters
          match (p:participant)<--(sm:sample)<--(dg)
          OPTIONAL MATCH (p)<--(file)
          where (file:clinical_measure_file or file: generic_file or file:radiology_file)
          with dg, opensearch_data, sample_file_filters, case COLLECT(file) when [] then [] else COLLECT(DISTINCT {
                    sample_anatomic_site: apoc.text.split(sm.anatomic_site, ';'),
                    participant_age_at_collection: sm.participant_age_at_collection,
                    sample_tumor_status: sm.sample_tumor_status,
                    tumor_classification: sm.tumor_classification,
                    data_category: apoc.text.split(file.data_category, ';'),
                    file_type: file.file_type,
                    file_mapping_level: file.file_mapping_level,
                    library_selection: null,
                    library_source_material: null,
                    library_source_molecule: null,
                    library_strategy: null
            }) end as participant_file_filters
          match (st:study)<--(cg:consent_group)<--(p:participant)<--(sm:sample)<--(dg)
          OPTIONAL MATCH (st)<--(file)
          where (file: clinical_measure_file or file: generic_file)
          with dg, opensearch_data, sample_file_filters, participant_file_filters, case COLLECT(file) when [] then [] else COLLECT(DISTINCT {
                    sample_anatomic_site: apoc.text.split(sm.anatomic_site, ';'),
                    participant_age_at_collection: sm.participant_age_at_collection,
                    sample_tumor_status: sm.sample_tumor_status,
                    tumor_classification: sm.tumor_classification,
                    data_category: apoc.text.split(file.data_category, ';'),
                    file_type: file.file_type,
                    file_mapping_level: file.file_mapping_level,
                    library_selection: null,
                    library_source_material: null,
                    library_source_molecule: null,
                    library_strategy: null
            }) end as study_file_filters
          with dg, opensearch_data, sample_file_filters, apoc.coll.union(participant_file_filters, study_file_filters) as non_sample_file_filters
          with dg, apoc.map.merge(opensearch_data, {
            sample_file_filters: sample_file_filters + non_sample_file_filters
          }) AS opensearch_data
          match (p:participant)<--(sm:sample)<--(dg)
          OPTIONAL MATCH (p)<-[:of_survival]-(su:survival)
          with dg, apoc.map.merge(opensearch_data, {
            survival_filters: COLLECT(DISTINCT {last_known_survival_status: su.last_known_survival_status,
              event_free_survival_status: su.event_free_survival_status,
              first_event: su.first_event,
              age_at_last_known_survival_status: su.age_at_last_known_survival_status})
          }) AS opensearch_data
          match (p:participant)<--(sm:sample)<--(dg)
          OPTIONAL MATCH (p)<-[:of_treatment]-(tm:treatment)
          with dg, apoc.map.merge(opensearch_data, {
            treatment_filters: COLLECT(DISTINCT{treatment_type: apoc.text.split(tm.treatment_type, ';'),
            treatment_agent: apoc.text.split(tm.treatment_agent, ';'),
            age_at_treatment_start: tm.age_at_treatment_start})
          }) AS opensearch_data
          match (p:participant)<--(sm:sample)<--(dg)
          OPTIONAL MATCH (p)<-[:of_treatment_response]-(tr:treatment_response)
          with dg, apoc.map.merge(opensearch_data, {
            treatment_response_filters: COLLECT(DISTINCT{response_category: tr.response_category,
            age_at_response: tr.age_at_response})
          }) AS opensearch_data
          match (p:participant)<--(sm:sample)<--(dg)
          optional match (sm)<--(file)
          WHERE (file: sequencing_file or file: generic_file OR file:pathology_file OR file:methylation_array_file OR file:cytogenomic_file)
          with dg, apoc.map.merge(opensearch_data, {
                      file_count: COUNT(DISTINCT file.dcf_indexd_guid),
                      files: COLLECT(DISTINCT file.dcf_indexd_guid)
                    }) AS opensearch_data         
          RETURN opensearch_data
        page_size: 100
      - query: |
          MATCH (p:participant)<-[:of_sample]-(sm1:sample)<--(cl)<--(sm2:sample)<--(dg:diagnosis)
          WHERE (cl: cell_line or cl: pdx)
          optional Match (sm1)<--(file1)
          WHERE (file1: sequencing_file or file1: generic_file OR file1:pathology_file OR file1:methylation_array_file OR file1:cytogenomic_file)
          optional Match (sm2)<--(file2)
          WHERE (file2: sequencing_file or file2: generic_file OR file2:pathology_file OR file2:methylation_array_file OR file2:cytogenomic_file)
          with dg, collect(distinct sm1) as sm1_list, collect(distinct sm2) as sm2_list, collect(distinct file1) as file1_list, collect(distinct file2) as file2_list
          with dg, apoc.coll.union(sm1_list, sm2_list) as samples, apoc.coll.union(file1_list, file2_list) as files
          unwind samples as sample
          with dg, sample, files
          UNWIND (case files when [] then [null] else files end)  AS file
          with dg, sample, file
          with dg, COLLECT(DISTINCT {
                    sample_anatomic_site: apoc.text.split(sample.anatomic_site, ';'),
                    participant_age_at_collection: sample.participant_age_at_collection,
                    sample_tumor_status: sample.sample_tumor_status,
                    tumor_classification: sample.tumor_classification,
                    data_category: apoc.text.split(file.data_category, ';'),
                    file_type: file.file_type,
                    file_mapping_level: file.file_mapping_level,
                    library_selection: CASE LABELS(file)[0]
                              WHEN 'sequencing_file' THEN file.library_selection
                              ELSE null END,
                    library_source_material: CASE LABELS(file)[0]
                              WHEN 'sequencing_file' THEN file.library_source_material
                              ELSE null END,
                    library_source_molecule: CASE LABELS(file)[0]
                              WHEN 'sequencing_file' THEN file.library_source_molecule
                              ELSE null END,
                    library_strategy: CASE LABELS(file)[0]
                              WHEN 'sequencing_file' THEN file.library_strategy
                              ELSE null END
            }) as sample_file_filter
          optional match (p:participant)<-[:of_sample]-(sm1:sample)<--(cl)<--(sm:sample)<--(dg)
          OPTIONAL MATCH (p)<--(file)
          where (file:clinical_measure_file or file: generic_file or file:radiology_file)
          with dg, sample_file_filter, case COLLECT(file) when [] then [] else COLLECT(DISTINCT {
                    sample_anatomic_site: apoc.text.split(sm.anatomic_site, ';'),
                    participant_age_at_collection: sm.participant_age_at_collection,
                    sample_tumor_status: sm.sample_tumor_status,
                    tumor_classification: sm.tumor_classification,
                    data_category: apoc.text.split(file.data_category, ';'),
                    file_type: file.file_type,
                    file_mapping_level: file.file_mapping_level,
                    library_selection: null,
                    library_source_material: null,
                    library_source_molecule: null,
                    library_strategy: null
            }) end as participant_file_filters_1,
            case COLLECT(file) when [] then [] else COLLECT(DISTINCT {
                    sample_anatomic_site: apoc.text.split(sm1.anatomic_site, ';'),
                    participant_age_at_collection: sm1.participant_age_at_collection,
                    sample_tumor_status: sm1.sample_tumor_status,
                    tumor_classification: sm1.tumor_classification,
                    data_category: apoc.text.split(file.data_category, ';'),
                    file_type: file.file_type,
                    file_mapping_level: file.file_mapping_level,
                    library_selection: null,
                    library_source_material: null,
                    library_source_molecule: null,
                    library_strategy: null
            }) end as participant_file_filters_2
          with dg, sample_file_filter, apoc.coll.union(participant_file_filters_1, participant_file_filters_2) as participant_file_filters
          optional match (st:study)<--(cg:consent_group)<--(p)<-[:of_sample]-(sm1:sample)<--(cl)<--(sm:sample)<--(dg)
          OPTIONAL MATCH (st)<--(file)
          where (file: clinical_measure_file or file: generic_file)
          with dg, sample_file_filter, participant_file_filters, case COLLECT(file) when [] then [] else COLLECT(DISTINCT {
                    sample_anatomic_site: apoc.text.split(sm.anatomic_site, ';'),
                    participant_age_at_collection: sm.participant_age_at_collection,
                    sample_tumor_status: sm.sample_tumor_status,
                    tumor_classification: sm.tumor_classification,
                    data_category: apoc.text.split(file.data_category, ';'),
                    file_type: file.file_type,
                    file_mapping_level: file.file_mapping_level,
                    library_selection: null,
                    library_source_material: null,
                    library_source_molecule: null,
                    library_strategy: null
            }) end as study_file_filters_1, case COLLECT(file) when [] then [] else COLLECT(DISTINCT {
                    sample_anatomic_site: apoc.text.split(sm1.anatomic_site, ';'),
                    participant_age_at_collection: sm1.participant_age_at_collection,
                    sample_tumor_status: sm1.sample_tumor_status,
                    tumor_classification: sm1.tumor_classification,
                    data_category: apoc.text.split(file.data_category, ';'),
                    file_type: file.file_type,
                    file_mapping_level: file.file_mapping_level,
                    library_selection: null,
                    library_source_material: null,
                    library_source_molecule: null,
                    library_strategy: null
            }) end as study_file_filters_2
          with dg, sample_file_filter, participant_file_filters, apoc.coll.union(study_file_filters_1, study_file_filters_2) as study_file_filters
          with dg, sample_file_filter + apoc.coll.union(participant_file_filters, study_file_filters) as sample_file_filters
          optional match (p:participant)<-[:of_sample]-(sm1:sample)<--(cl)<--(sm:sample)<--(dg)
          WHERE (cl: cell_line or cl: pdx)
          optional match (sm)<--(file)
          WHERE (file: sequencing_file or file: generic_file OR file:pathology_file OR file:methylation_array_file OR file:cytogenomic_file)
          with dg, sample_file_filters, collect(distinct file.dcf_indexd_guid) as files, apoc.coll.union(collect(distinct sm1.id), collect(distinct sm.id)) as sid, apoc.coll.union(collect(distinct sm1.sample_id), collect(distinct sm.sample_id))  as sample_id
          optional match (p:participant)<-[*..4]-(dg)
          OPTIONAL MATCH (p)<-[:of_survival]-(su:survival)
          OPTIONAL MATCH (p)<-[:of_treatment]-(tm:treatment)
          OPTIONAL MATCH (p)<-[:of_treatment_response]-(tr:treatment_response)
          OPTIONAL MATCH (st:study)<-[:of_consent_group]-(cg:consent_group)<-[:of_participant]-(p)
          OPTIONAL MATCH (st)<-[:of_study_personnel]-(stp:study_personnel)
          OPTIONAL MATCH (st)<-[:of_study_funding]-(stf:study_funding)
          WITH dg, p, sid, sample_id, sample_file_filters, files, COLLECT(DISTINCT {last_known_survival_status: su.last_known_survival_status, 
              event_free_survival_status: su.event_free_survival_status, 
              first_event: su.first_event,
              age_at_last_known_survival_status: su.age_at_last_known_survival_status} ) AS survival_filters,
            COLLECT(DISTINCT{treatment_type: apoc.text.split(tm.treatment_type, ';'),
            treatment_agent: apoc.text.split(tm.treatment_agent, ';'),
            age_at_treatment_start: tm.age_at_treatment_start}) as treatment_filters,
            COLLECT(DISTINCT{response_category: tr.response_category,
            age_at_response: tr.age_at_response}) as treatment_response_filters, st, stf, stp          
          RETURN DISTINCT
            dg.id as id,
            p.id as pid,
            sid as sid,
            sample_id as sample_id,
            dg.diagnosis_id as diagnosis_id,
            dg.diagnosis as diagnosis,
            dg.disease_phase as disease_phase,
            dg.diagnosis_classification_system as diagnosis_classification_system,
            apoc.text.split(dg.diagnosis_category, ';') as diagnosis_category,
            dg.diagnosis_category as diagnosis_category_str,
            dg.diagnosis_basis as diagnosis_basis,
            dg.tumor_grade_source as tumor_grade_source,
            dg.tumor_stage_source as tumor_stage_source,
            apoc.text.split(dg.anatomic_site, ';') as diagnosis_anatomic_site,
            dg.anatomic_site as diagnosis_anatomic_site_str,
            dg.age_at_diagnosis as age_at_diagnosis,
            p.participant_id as participant_id,
            apoc.text.split(p.race, ';') as race,
            p.sex_at_birth as sex_at_birth,
            st.study_id as study_id,
            st.dbgap_accession as dbgap_accession,
            st.study_status AS study_status,
            st.study_acronym as study_acronym,
            st.study_name as study_name,
            survival_filters as survival_filters,
            treatment_filters as treatment_filters,
            treatment_response_filters as treatment_response_filters,    
            sample_file_filters AS sample_file_filters,
            size(files) as file_count,
            files as files
      - query: |
          match (st:study)<--(cl)<--(sm:sample)<--(dg:diagnosis)
          where (cl: cell_line or cl: pdx)
          optional match (sm)<--(file)
          where (file: sequencing_file or file: generic_file OR file:pathology_file OR file:methylation_array_file OR file:cytogenomic_file)
          with dg, COLLECT(DISTINCT {
                    sample_anatomic_site: apoc.text.split(sm.anatomic_site, ';'),
                    participant_age_at_collection: sm.participant_age_at_collection,
                    sample_tumor_status: sm.sample_tumor_status,
                    tumor_classification: sm.tumor_classification,
                    data_category: apoc.text.split(file.data_category, ';'),
                    file_type: file.file_type,
                    file_mapping_level: file.file_mapping_level,
                    library_selection: CASE LABELS(file)[0]
                              WHEN 'sequencing_file' THEN file.library_selection
                              ELSE null END,
                    library_source_material: CASE LABELS(file)[0]
                              WHEN 'sequencing_file' THEN file.library_source_material
                              ELSE null END,
                    library_source_molecule: CASE LABELS(file)[0]
                              WHEN 'sequencing_file' THEN file.library_source_molecule
                              ELSE null END,
                    library_strategy: CASE LABELS(file)[0]
                              WHEN 'sequencing_file' THEN file.library_strategy
                              ELSE null END
            }) as sample_file_filter
          optional match (st:study)<--(cl)<--(sm:sample)<--(dg)
          where (cl: cell_line or cl: pdx)
          OPTIONAL MATCH (st)<--(file)
          where (file: clinical_measure_file or file: generic_file)
          with dg, sample_file_filter, case COLLECT(file) when [] then [] else COLLECT(DISTINCT {
                    sample_anatomic_site: apoc.text.split(sm.anatomic_site, ';'),
                    participant_age_at_collection: sm.participant_age_at_collection,
                    sample_tumor_status: sm.sample_tumor_status,
                    tumor_classification: sm.tumor_classification,
                    data_category: apoc.text.split(file.data_category, ';'),
                    file_type: file.file_type,
                    file_mapping_level: file.file_mapping_level,
                    library_selection: null,
                    library_source_material: null,
                    library_source_molecule: null,
                    library_strategy: null
            }) end as study_file_filters
          with dg, sample_file_filter + study_file_filters as sample_file_filters
          optional match (st:study)<--(cl)<--(sm:sample)<--(dg)
          where (cl: cell_line or cl: pdx)
          optional match (sm)<--(file)
          where (file: sequencing_file or file: generic_file OR file:pathology_file OR file:methylation_array_file OR file:cytogenomic_file)
          OPTIONAL MATCH (st)<-[:of_study_personnel]-(stp:study_personnel)
          OPTIONAL MATCH (st)<-[:of_study_funding]-(stf:study_funding)
          WITH dg, sm, sample_file_filters, file, st, stf, stp
          RETURN DISTINCT
            dg.id as id,
            null as pid,
            sm.id as sid,
            sm.sample_id as sample_id,
            dg.diagnosis_id as diagnosis_id,
            dg.diagnosis as diagnosis,
            dg.disease_phase as disease_phase,
            dg.diagnosis_classification_system as diagnosis_classification_system,
            apoc.text.split(dg.diagnosis_category, ';') as diagnosis_category,
            dg.diagnosis_category as diagnosis_category_str,
            dg.diagnosis_basis as diagnosis_basis,
            dg.tumor_grade_source as tumor_grade_source,
            dg.tumor_stage_source as tumor_stage_source,
            apoc.text.split(dg.anatomic_site, ';') as diagnosis_anatomic_site,
            dg.anatomic_site as diagnosis_anatomic_site_str,
            dg.age_at_diagnosis as age_at_diagnosis,
            null as participant_id,
            null as race,
            null as sex_at_birth,
            st.study_id as study_id,
            st.dbgap_accession as dbgap_accession,
            st.study_status AS study_status,
            st.study_acronym as study_acronym,
            st.study_name as study_name,
            COLLECT(DISTINCT {
                last_known_survival_status: null,
                age_at_last_known_survival_status: null,
                event_free_survival_status: null,
                first_event: null
            }) AS survival_filters,
            COLLECT(DISTINCT{treatment_type: null,
            treatment_agent: null,
            age_at_treatment_start: null}) as treatment_filters,
            COLLECT(DISTINCT{response_category: null,
            age_at_response: null}) as treatment_response_filters, 
            sample_file_filters AS sample_file_filters,
            COUNT(DISTINCT file.dcf_indexd_guid) as file_count,
            COLLECT(DISTINCT file.dcf_indexd_guid) as files

  - index_name: studies
    type: neo4j
    mapping:
      id:
        type: keyword
      study_id:
        type: keyword
      grant_id:
        type: keyword
      pubmed_ids:
        type: keyword
      dbgap_accession:
        type: keyword
      study_status:
        type: keyword
      study_name:
        type: keyword
      study_description:
        type: keyword
      study_acronym:
        type: keyword
      PIs:
        type: keyword
      study_id_gs:
        type: search_as_you_type
      study_name_gs:
        type: search_as_you_type
      study_status_gs:
        type: search_as_you_type
      num_of_participants:
        type: integer
      num_of_diagnoses:
        type: integer
      diagnosis_cancer:
        type: text
        fields:
          keyword:
            type: keyword
      diagnosis_anatomic_site:
        type: text
        fields:
          keyword:
            type: keyword
      file_types:
        type: text
        fields:
          keyword:
            type: keyword
      num_of_samples:
        type: integer
      num_of_files:
        type: integer
      files:
        type: text
        fields:
          keyword:
            type: keyword
    # Cypher query will be used to retrieve data from Neo4j, and index into Elasticsearch
    cypher_queries:
      - query: |
          MATCH (st:study)<-[:of_consent_group]-(cg:consent_group)<-[:of_participant]-(p:participant)
          with st, count(p) as num_p
          MATCH (st:study)<-[*..6]-(dg:diagnosis)
          with st, num_p, count(dg) as num_diag
          MATCH (st:study)<-[*..6]-(dg:diagnosis)
          with st, num_p, num_diag, dg.diagnosis as dg_cancers, count(dg.diagnosis) as num_cancers
          ORDER BY num_cancers desc
          with st, num_p, num_diag, collect(dg_cancers + ' (' + toString(num_cancers) + ')') as cancers
          MATCH (st)<-[*..6]-(diag:diagnosis)
          with st, num_p, num_diag, cancers, apoc.text.split(diag.anatomic_site, ';') as dg_sites
          unwind dg_sites as dg_site
          with st, num_p, num_diag, cancers, dg_site
          with st, num_p, num_diag, cancers, dg_site, count(dg_site) as num_sites
          ORDER BY num_sites desc
          with st, num_p, num_diag, cancers, collect(dg_site + ' (' + toString(num_sites) + ')') as sites
          MATCH (st)<-[*..6]-(fl)
          WHERE (fl:clinical_measure_file or fl: generic_file OR fl: sequencing_file OR fl:pathology_file OR fl:radiology_file OR fl:methylation_array_file OR fl:cytogenomic_file)
          with st, num_p, num_diag, cancers, sites, fl.file_type as ft, count(distinct fl.dcf_indexd_guid) as num_ft
          ORDER BY num_ft desc
          with st, num_p, num_diag, cancers, sites, collect(ft + ' (' + toString(num_ft) + ')') as file_types, sum(num_ft) as num_files
          OPTIONAL MATCH (st)<-[*..2]-(pcp)<-[:of_sample]-(sm1:sample)
          WHERE (pcp:participant or pcp:cell_line or pcp:pdx)
          WITH st, num_p, num_diag, cancers, sites, file_types, num_files, count(distinct sm1.sample_id) as num_samples_1
          OPTIONAL MATCH (st)<-[:of_consent_group]-(cg:consent_group)<-[:of_participant]-(participant)<-[:of_sample]-(sm1:sample)<--(cp)<--(sm2:sample)
          WHERE (cp:cell_line or cp:pdx)
          WITH st, num_p, num_diag, cancers, sites, file_types, num_files, num_samples_1, count(distinct sm2.sample_id) as num_samples_2
          WITH st, num_p, num_diag, cancers, sites, file_types, num_files, num_samples_1 + num_samples_2 as num_samples
          MATCH (st)<-[*..6]-(file)
          WHERE (file:clinical_measure_file or file: generic_file OR file: sequencing_file OR file:pathology_file OR file:radiology_file OR file:methylation_array_file OR file:cytogenomic_file)
          OPTIONAL MATCH (st)<-[:of_publication]-(pub:publication)
          OPTIONAL MATCH (st)<-[:of_study_personnel]-(stp:study_personnel)
          WHERE stp.personnel_type = 'PI'
          OPTIONAL MATCH (st)<-[:of_study_funding]-(stf:study_funding)
          WITH st, num_p, num_diag, cancers, sites, file_types, num_files, num_samples, file.dcf_indexd_guid as file_id, stf, stp, pub
          RETURN DISTINCT
            st.id as id,
            st.study_id as study_id,
            apoc.text.join(COLLECT(DISTINCT stf.grant_id), ';') as grant_id,
            apoc.text.join(COLLECT(DISTINCT pub.pubmed_id), ';') as pubmed_ids,
            st.dbgap_accession as dbgap_accession,
            st.study_status AS study_status,
            st.study_name as study_name,
            st.study_description as study_description,
            st.study_acronym as study_acronym,
            apoc.text.join(COLLECT(DISTINCT stp.personnel_name), ';') as PIs,
            st.study_id as study_id_gs,
            st.study_name as study_name_gs,
            st.study_status as study_status_gs,
            num_p as num_of_participants,
            num_diag as num_of_diagnoses,
            cancers as diagnosis_cancer,
            sites as diagnosis_anatomic_site,
            file_types as file_types,
            num_samples as num_of_samples,
            num_files as num_of_files,
            COLLECT(DISTINCT file_id) as files
  
  - index_name: samples
    type: neo4j
    mapping:
      id:
        type: keyword
      pid:
        type: keyword
      sample_id:
        type: keyword
      participant_id:
        type: keyword
      race:
        type: keyword
      sex_at_birth:
        type: keyword
      sample_anatomic_site:
        type: keyword
      sample_anatomic_site_str:
        type: keyword     
      participant_age_at_collection:
        type: integer
      sample_tumor_status:
        type: keyword
      tumor_classification:
        type: keyword
      study_id:
        type: keyword
      dbgap_accession:
        type: keyword
      study_status:
        type: keyword
      study_acronym:
        type: keyword
      study_name:
        type: keyword
      diagnosis_str:
        type: keyword
      diagnosis_category_str:
        type: keyword
      diagnosis_comment_str:
        type: keyword
      diagnosis_anatomic_site_str:
        type: keyword
      age_at_diagnosis_str:
        type: keyword
      sample_id_gs:
        type: search_as_you_type
      participant_id_gs:
        type: search_as_you_type
      study_id_gs:
        type: search_as_you_type
      sample_anatomic_site_str_gs:
        type: search_as_you_type
      sample_tumor_status_gs:
        type: search_as_you_type
      diagnosis_str_gs:
        type: search_as_you_type
      diagnosis_category_str_gs:
        type: search_as_you_type
      tumor_classification_gs:
        type: search_as_you_type
      diagnosis_filters:
        type: nested
        properties:
          age_at_diagnosis:
            type: integer
          diagnosis_anatomic_site:
            type: keyword
          disease_phase:
            type: keyword
          diagnosis_classification_system:
            type: keyword
          diagnosis_basis:
            type: keyword
          tumor_grade_source:
            type: keyword  
          tumor_stage_source:
            type: keyword    
          diagnosis:
            type: keyword
          diagnosis_category:
            type: keyword
      file_filters:
        type: nested
        properties:
          data_category:
            type: keyword
          file_type:
            type: keyword
          file_mapping_level:
            type: keyword            
          library_selection:
            type: keyword
          library_source_material:
            type: keyword
          library_source_molecule:
            type: keyword
          library_strategy:
            type: keyword
      survival_filters:
        type: nested
        properties:
          last_known_survival_status:
            type: keyword
          age_at_last_known_survival_status:
            type: integer
          event_free_survival_status:
            type: keyword
          first_event:
            type: keyword
      treatment_filters:
        type: nested
        properties:
          treatment_type:
            type: keyword
          treatment_agent:
            type: keyword
          age_at_treatment_start:
            type: integer
      treatment_response_filters:
        type: nested
        properties:
          response_category:
            type: keyword
          age_at_response:
            type: integer
      file_count:
        type: integer
      direct_file_count:
        type: integer
      files:
        type: text
        fields:
          keyword:
            type: keyword
    # Cypher query will be used to retrieve data from Neo4j, and index into Elasticsearch
    cypher_queries:
      - query: |
          MATCH (sm:sample)
          WITH sm, {
            id: sm.id,
            sample_id: sm.sample_id,
            sample_id_gs: sm.sample_id,
            sample_anatomic_site: apoc.text.split(sm.anatomic_site, ';'),
            sample_anatomic_site_str: sm.anatomic_site,
            sample_anatomic_site_str_gs: sm.anatomic_site,
            participant_age_at_collection: sm.participant_age_at_collection,
            sample_tumor_status: sm.sample_tumor_status,
            sample_tumor_status_gs: sm.sample_tumor_status,
            tumor_classification: sm.tumor_classification,
            tumor_classification_gs: sm.tumor_classification
          } AS opensearch_data
          MATCH (sm)-[*..3]->(p:participant)
          WITH sm, apoc.map.merge(opensearch_data, {
            pid: p.id,
            participant_id: p.participant_id,
            participant_id_gs: p.participant_id,
            race: apoc.text.split(p.race, ';'),
            sex_at_birth: p.sex_at_birth
          }) AS opensearch_data
          SKIP $skip LIMIT $limit
          OPTIONAL MATCH (sm)-[*..3]->(:participant)<--(dg:diagnosis)
          WITH sm, opensearch_data, COLLECT(DISTINCT {
            age_at_diagnosis: dg.age_at_diagnosis,
            diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
            disease_phase: dg.disease_phase,
            diagnosis_classification_system: dg.diagnosis_classification_system,
            diagnosis_category: apoc.text.split(dg.diagnosis_category, ';'),
            diagnosis_basis: dg.diagnosis_basis,
            tumor_grade_source: dg.tumor_grade_source,
            tumor_stage_source: dg.tumor_stage_source,
            diagnosis: dg.diagnosis
          }) AS diagnosis_filter
          OPTIONAL MATCH (sm)<-[*..3]-(dg:diagnosis)
          WITH sm, apoc.map.merge(opensearch_data, {
            diagnosis_filters: apoc.coll.union(diagnosis_filter, COLLECT(DISTINCT{
              age_at_diagnosis: dg.age_at_diagnosis,
              diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
              disease_phase: dg.disease_phase,
              diagnosis_classification_system: dg.diagnosis_classification_system,
              diagnosis_category: apoc.text.split(dg.diagnosis_category, ';'),
              diagnosis_basis: dg.diagnosis_basis,
              tumor_grade_source: dg.tumor_grade_source,
              tumor_stage_source: dg.tumor_stage_source,
              diagnosis: dg.diagnosis
            }))
          }) AS opensearch_data
          OPTIONAL MATCH (sm)<-[*..3]-(file:sequencing_file)
          WITH sm, opensearch_data, COLLECT(DISTINCT {
            data_category: apoc.text.split(file.data_category, ';'),
            file_type: file.file_type,
            file_mapping_level: file.file_mapping_level,
            library_selection: file.library_selection,
            library_source_material: file.library_source_material,
            library_source_molecule: file.library_source_molecule,
            library_strategy: file.library_strategy
          }) AS file_filter,
          COLLECT(DISTINCT file.dcf_indexd_guid) AS files
          OPTIONAL MATCH (sm)<-[*..3]-(file:generic_file)
          WITH sm, opensearch_data, apoc.coll.union(file_filter, COLLECT(DISTINCT {
            data_category: apoc.text.split(file.data_category, ';'),
            file_type: file.file_type,
            file_mapping_level: file.file_mapping_level,
            library_selection: null,
            library_source_material: null,
            library_source_molecule: null,
            library_strategy: null
          })) AS file_filter,
          apoc.coll.union(files, COLLECT(DISTINCT file.dcf_indexd_guid)) AS files
          OPTIONAL MATCH (sm)<-[*..3]-(file:pathology_file)
          WITH sm, opensearch_data, apoc.coll.union(file_filter, COLLECT(DISTINCT {
            data_category: apoc.text.split(file.data_category, ';'),
            file_type: file.file_type,
            file_mapping_level: file.file_mapping_level,
            library_selection: null,
            library_source_material: null,
            library_source_molecule: null,
            library_strategy: null
          })) AS file_filter,
          apoc.coll.union(files, COLLECT(DISTINCT file.dcf_indexd_guid)) AS files
          OPTIONAL MATCH (sm)<-[*..3]-(file:cytogenomic_file)
          WITH sm, opensearch_data, apoc.coll.union(file_filter, COLLECT(DISTINCT {
            data_category: apoc.text.split(file.data_category, ';'),
            file_type: file.file_type,
            file_mapping_level: file.file_mapping_level,
            library_selection: null,
            library_source_material: null,
            library_source_molecule: null,
            library_strategy: null
          })) AS file_filter,
          apoc.coll.union(files, COLLECT(DISTINCT file.dcf_indexd_guid)) AS files
          OPTIONAL MATCH (sm)<-[*..3]-(file:methylation_array_file)
          WITH sm, opensearch_data, apoc.coll.union(file_filter, COLLECT(DISTINCT {
            data_category: apoc.text.split(file.data_category, ';'),
            file_type: file.file_type,
            file_mapping_level: file.file_mapping_level,
            library_selection: null,
            library_source_material: null,
            library_source_molecule: null,
            library_strategy: null
          })) AS file_filter,
          apoc.coll.union(files, COLLECT(DISTINCT file.dcf_indexd_guid)) AS files
          WITH sm, apoc.map.merge(opensearch_data, {
            file_filters: file_filter,
            files: files,
            file_count: SIZE(files)
          }) AS opensearch_data
          MATCH (sm)-[*..3]->(:participant)-[:of_participant]->(cg:consent_group)-[:of_consent_group]->(st:study)
          WITH sm, apoc.map.merge(opensearch_data, {
            study_id: st.study_id,
            study_id_gs: st.study_id,
            dbgap_accession: st.dbgap_accession,
            study_status: st.study_status,
            study_acronym: st.study_acronym,
            study_name: st.study_name
          }) AS opensearch_data
          OPTIONAL MATCH (sm)<--(direct_file)
          WITH sm, apoc.map.merge(opensearch_data, {
            direct_file_count: COUNT(DISTINCT direct_file.dcf_indexd_guid)
          }) AS opensearch_data
          OPTIONAL MATCH (sm)-[*..3]->(:participant)<-[:of_survival]-(su:survival)
          WITH sm, opensearch_data, COLLECT(DISTINCT {last_known_survival_status: su.last_known_survival_status, 
              event_free_survival_status: su.event_free_survival_status, 
              first_event: su.first_event,
              age_at_last_known_survival_status: su.age_at_last_known_survival_status} ) AS survival_filters
          WITH sm, apoc.map.merge(opensearch_data, {
            survival_filters: survival_filters
          }) AS opensearch_data
          OPTIONAL MATCH (sm)-[*..3]->(:participant)<-[:of_treatment]-(tm:treatment)
          WITH sm, opensearch_data, COLLECT(DISTINCT{treatment_type: apoc.text.split(tm.treatment_type, ';'),
            treatment_agent: apoc.text.split(tm.treatment_agent, ';'),
            age_at_treatment_start: tm.age_at_treatment_start}) as treatment_filters
          WITH sm, apoc.map.merge(opensearch_data, {
            treatment_filters: treatment_filters
          }) AS opensearch_data
          OPTIONAL MATCH (sm)-[*..3]->(:participant)<-[:of_treatment_response]-(tr:treatment_response)
          WITH sm, opensearch_data, COLLECT(DISTINCT{response_category: tr.response_category,
            age_at_response: tr.age_at_response}) as treatment_response_filters
          WITH sm, apoc.map.merge(opensearch_data, {
            treatment_response_filters: treatment_response_filters
          }) AS opensearch_data
          OPTIONAL MATCH (sm)<-[*..3]-(dg:diagnosis)
          WITH sm, apoc.map.merge(opensearch_data, {
            diagnosis_str: apoc.text.join(COLLECT(distinct dg.diagnosis), ';'),
            diagnosis_category_str: apoc.text.join(apoc.coll.toSet(apoc.text.split(apoc.text.join(COLLECT(distinct dg.diagnosis_category), ';'), ';')), ';'),
            diagnosis_str_gs: apoc.text.join(COLLECT(distinct dg.diagnosis), ';'),
            diagnosis_category_str_gs: apoc.text.join(apoc.coll.toSet(apoc.text.split(apoc.text.join(COLLECT(distinct dg.diagnosis_category), ';'), ';')), ';'),
            diagnosis_comment_str: apoc.text.join(COLLECT(distinct dg.diagnosis_comment), ';'),
            diagnosis_anatomic_site_str: apoc.text.join(apoc.coll.toSet(apoc.text.split(apoc.text.join(COLLECT(distinct dg.anatomic_site), ';'), ';')), ';'),
            age_at_diagnosis_str: apoc.text.join(COLLECT(distinct toString(case dg.age_at_diagnosis when -999 then 'Not Reported' else coalesce(dg.age_at_diagnosis, '') end)), ';')
          }) AS opensearch_data
          return opensearch_data
        page_size: 500
      - query: |
          MATCH (sm:sample)
          MATCH (st:study)<-[:of_cell_line|of_pdx]-(cl)<--(sm)
          Where (cl:cell_line or cl:pdx)
          optional Match (sm)<--(file)
          WHERE (file: sequencing_file or file: generic_file OR file:pathology_file OR file:methylation_array_file OR file:cytogenomic_file)
          OPTIONAL MATCH (sm)<-[:of_diagnosis]-(dg:diagnosis)
          OPTIONAL MATCH (st)<-[:of_study_personnel]-(stp:study_personnel)
          OPTIONAL MATCH (st)<-[:of_study_funding]-(stf:study_funding)
          WITH sm, file, st, stf, stp, dg
          RETURN DISTINCT
            sm.id as id,
            null as pid,
            sm.sample_id as sample_id,
            null as participant_id,
            null as race,
            null as sex_at_birth,
            apoc.text.split(sm.anatomic_site, ';') as sample_anatomic_site,
            sm.anatomic_site as sample_anatomic_site_str,
            sm.participant_age_at_collection as participant_age_at_collection,
            sm.sample_tumor_status as sample_tumor_status,
            sm.tumor_classification as tumor_classification,
            st.study_id as study_id,
            st.dbgap_accession as dbgap_accession,
            st.study_status AS study_status,
            st.study_acronym as study_acronym,
            st.study_name as study_name,
            apoc.text.join(COLLECT(distinct dg.diagnosis), ';') as diagnosis_str,
            apoc.text.join(apoc.coll.toSet(apoc.text.split(apoc.text.join(COLLECT(distinct dg.diagnosis_category), ';'), ';')), ';') as diagnosis_category_str,
            apoc.text.join(COLLECT(distinct dg.diagnosis_comment), ';') as diagnosis_comment_str,
            apoc.text.join(apoc.coll.toSet(apoc.text.split(apoc.text.join(COLLECT(distinct dg.anatomic_site), ';'), ';')), ';') as diagnosis_anatomic_site_str,
            apoc.text.join(COLLECT(distinct toString(case dg.age_at_diagnosis when -999 then 'Not Reported' else coalesce(dg.age_at_diagnosis, '') end)), ';') as age_at_diagnosis_str,
            sm.sample_id as sample_id_gs,
            null as participant_id_gs,
            st.study_id as study_id_gs,
            sm.anatomic_site as sample_anatomic_site_str_gs,
            sm.sample_tumor_status as sample_tumor_status_gs,
            apoc.text.join(COLLECT(distinct dg.diagnosis), ';') as diagnosis_str_gs,
            apoc.text.join(apoc.coll.toSet(apoc.text.split(apoc.text.join(COLLECT(distinct dg.diagnosis_category), ';'), ';')), ';') as diagnosis_category_str_gs,
            sm.tumor_classification as tumor_classification_gs,
            COLLECT(DISTINCT {
                age_at_diagnosis: dg.age_at_diagnosis,
                diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                disease_phase: dg.disease_phase,
                diagnosis_classification_system: dg.diagnosis_classification_system,
                diagnosis_category: apoc.text.split(dg.diagnosis_category, ';'),
                diagnosis_basis: dg.diagnosis_basis,
                tumor_grade_source: dg.tumor_grade_source,
                tumor_stage_source: dg.tumor_stage_source,
                diagnosis: dg.diagnosis
            }) AS diagnosis_filters,
            null AS survival_filters,
            null as treatment_filters,
            null as treatment_response_filters,
            CASE COLLECT(file) WHEN [] THEN []
                      ELSE COLLECT(DISTINCT {
                          data_category: apoc.text.split(file.data_category, ';'),
                          file_type: file.file_type,
                          file_mapping_level: file.file_mapping_level,
                          library_selection: CASE LABELS(file)[0]
                                        WHEN 'sequencing_file' THEN file.library_selection
                                        ELSE null END,
                          library_source_material: CASE LABELS(file)[0]
                                        WHEN 'sequencing_file' THEN file.library_source_material
                                        ELSE null END,
                          library_source_molecule: CASE LABELS(file)[0]
                                        WHEN 'sequencing_file' THEN file.library_source_molecule
                                        ELSE null END,
                          library_strategy: CASE LABELS(file)[0]
                                        WHEN 'sequencing_file' THEN file.library_strategy
                                        ELSE null END
                      }) END AS file_filters,
            COUNT(DISTINCT file.dcf_indexd_guid) as file_count,
            COUNT(DISTINCT file.dcf_indexd_guid) as direct_file_count,
            COLLECT(DISTINCT file.dcf_indexd_guid) as files

  - index_name: files
    type: neo4j
    mapping:
      id:
        type: keyword
      pid:
        type: keyword
      file_id:
        type: keyword
      guid:
        type: keyword
      file_name:
        type: keyword
      file_access:
        type: keyword
      data_category:
        type: keyword
      file_type:
        type: keyword
      file_mapping_level:
        type: keyword
      file_description:
        type: keyword
      file_size:
        type: long
      md5sum:
        type: keyword
      study_id:
        type: keyword
      dbgap_accession:
        type: keyword
      study_status:
        type: keyword
      study_acronym:
        type: keyword
      study_name:
        type: keyword
      participant_id:
        type: keyword
      sample_id:
        type: keyword
      participant_id_gs:
        type: search_as_you_type
      sample_id_gs:
        type: search_as_you_type
      study_id_gs:
        type: search_as_you_type
      file_description_gs:
        type: search_as_you_type
      file_type_gs:
        type: search_as_you_type
      file_name_gs:
        type: search_as_you_type
      data_category_gs:
        type: search_as_you_type
      files:
        type: text
        fields:
          keyword:
            type: keyword
      combined_filters:
        type: nested
        properties:
          participant_id:
            type: keyword
          race:
            type: keyword
          sex_at_birth:
            type: keyword
          survival_filters:
            type: nested
            properties:
              last_known_survival_status:
                type: keyword
              age_at_last_known_survival_status:
                type: integer
              event_free_survival_status:
                type: keyword
              first_event:
                type: keyword
          treatment_filters:
            type: nested
            properties:
              treatment_type:
                type: keyword
              treatment_agent:
                type: keyword
              age_at_treatment_start:
                type: integer
          treatment_response_filters:
            type: nested
            properties:
              response_category:
                type: keyword
              age_at_response:
                type: integer
          sample_diagnosis_filters:
            type: nested
            properties:
              sample_anatomic_site:
                type: keyword
              participant_age_at_collection:
                type: integer
              sample_tumor_status:
                type: keyword
              tumor_classification:
                type: keyword
              age_at_diagnosis:
                type: integer
              diagnosis_anatomic_site:
                type: keyword
              disease_phase:
                type: keyword
              diagnosis_classification_system:
                type: keyword
              diagnosis_basis:
                type: keyword
              tumor_grade_source:
                type: keyword  
              tumor_stage_source:
                type: keyword   
              diagnosis:
                type: keyword
              diagnosis_category:
                type: keyword
      library_selection:
        type: keyword
        fields:
          sort:
            type: keyword
            normalizer: lowercase
      library_source_material:
        type: keyword
        fields:
          sort:
            type: keyword
            normalizer: lowercase
      library_source_molecule:
        type: keyword
        fields:
          sort:
            type: keyword
            normalizer: lowercase
      library_strategy:
        type: keyword
        fields:
          sort:
            type: keyword
            normalizer: lowercase
    # Cypher query will be used to retrieve data from Neo4j, and index into Elasticsearch
    cypher_queries:
      - query: |
          MATCH (file)
          where (file:clinical_measure_file or file: generic_file or file:radiology_file)
          MATCH (p:participant)<--(file)
          with distinct file.dcf_indexd_guid as file_guid
          SKIP $skip LIMIT $limit
          MATCH (file)
          where (file:clinical_measure_file or file: generic_file or file:radiology_file) and file.dcf_indexd_guid = file_guid
          MATCH (p:participant)<--(file)
          optional MATCH (p)<-[*0..3]-(sm:sample)
          OPTIONAL MATCH (p)<-[:of_diagnosis]-(dg:diagnosis)
          with file, p, CASE WHEN collect(sm) <> [] OR collect(dg) <> [] THEN COLLECT(DISTINCT {
                                        sample_anatomic_site: apoc.text.split(sm.anatomic_site, ';'),
                                        participant_age_at_collection: sm.participant_age_at_collection,
                                        sample_tumor_status: sm.sample_tumor_status,
                                        tumor_classification: sm.tumor_classification,
                                        age_at_diagnosis: dg.age_at_diagnosis,
                                        diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                                        disease_phase: dg.disease_phase,
                                        diagnosis_classification_system: dg.diagnosis_classification_system,
                                        diagnosis_category: apoc.text.split(dg.diagnosis_category, ';'),
                                        diagnosis_basis: dg.diagnosis_basis,
                                        tumor_grade_source: dg.tumor_grade_source,
                                        tumor_stage_source: dg.tumor_stage_source,
                                        diagnosis: dg.diagnosis
                                    }) ELSE [] END as sample_diagnosis_filter_1
          MATCH (p)<--(file)
          optional MATCH (p)<-[:of_sample]-(sm:sample)
          OPTIONAL MATCH (sm)<--(dg:diagnosis)
          with file, p, sample_diagnosis_filter_1, CASE WHEN collect(sm) <> [] OR collect(dg) <> [] THEN COLLECT(DISTINCT {
                                        sample_anatomic_site: apoc.text.split(sm.anatomic_site, ';'),
                                        participant_age_at_collection: sm.participant_age_at_collection,
                                        sample_tumor_status: sm.sample_tumor_status,
                                        tumor_classification: sm.tumor_classification,
                                        age_at_diagnosis: dg.age_at_diagnosis,
                                        diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                                        disease_phase: dg.disease_phase,
                                        diagnosis_classification_system: dg.diagnosis_classification_system,
                                        diagnosis_category: apoc.text.split(dg.diagnosis_category, ';'),
                                        diagnosis_basis: dg.diagnosis_basis,
                                        tumor_grade_source: dg.tumor_grade_source,
                                        tumor_stage_source: dg.tumor_stage_source,
                                        diagnosis: dg.diagnosis
                                    }) ELSE [] END as sample_diagnosis_filter_2
          with file, p, apoc.coll.union(sample_diagnosis_filter_1, sample_diagnosis_filter_2) as sample_diagnosis_filter_3
          MATCH (p)<--(file)
          optional MATCH (p)<-[:of_sample]-(sm1:sample)<-[*2..2]-(sm:sample)
          OPTIONAL MATCH (sm1)<--(dg:diagnosis)
          with file, p, sample_diagnosis_filter_3, CASE WHEN collect(sm) <> [] OR collect(dg) <> [] THEN COLLECT(DISTINCT {
                                        sample_anatomic_site: apoc.text.split(sm.anatomic_site, ';'),
                                        participant_age_at_collection: sm.participant_age_at_collection,
                                        sample_tumor_status: sm.sample_tumor_status,
                                        tumor_classification: sm.tumor_classification,
                                        age_at_diagnosis: dg.age_at_diagnosis,
                                        diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                                        disease_phase: dg.disease_phase,
                                        diagnosis_classification_system: dg.diagnosis_classification_system,
                                        diagnosis_category: apoc.text.split(dg.diagnosis_category, ';'),
                                        diagnosis_basis: dg.diagnosis_basis,
                                        tumor_grade_source: dg.tumor_grade_source,
                                        tumor_stage_source: dg.tumor_stage_source,
                                        diagnosis: dg.diagnosis
                                    }) ELSE [] END as sample_diagnosis_filter_4
          with file, p, apoc.coll.union(sample_diagnosis_filter_3, sample_diagnosis_filter_4) as sample_diagnosis_filter_5
          MATCH (p)<--(file)
          optional MATCH (p)<-[:of_sample]-(sm1:sample)<-[*2..2]-(sm:sample)
          OPTIONAL MATCH (sm)<--(dg:diagnosis)
          with file, p, sample_diagnosis_filter_5, apoc.coll.union(CASE WHEN collect(sm1) <> [] OR collect(dg) <> [] THEN COLLECT(DISTINCT {
                                        sample_anatomic_site: apoc.text.split(sm1.anatomic_site, ';'),
                                        participant_age_at_collection: sm1.participant_age_at_collection,
                                        sample_tumor_status: sm1.sample_tumor_status,
                                        tumor_classification: sm1.tumor_classification,
                                        age_at_diagnosis: dg.age_at_diagnosis,
                                        diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                                        disease_phase: dg.disease_phase,
                                        diagnosis_classification_system: dg.diagnosis_classification_system,
                                        diagnosis_category: apoc.text.split(dg.diagnosis_category, ';'),
                                        diagnosis_basis: dg.diagnosis_basis,
                                        tumor_grade_source: dg.tumor_grade_source,
                                        tumor_stage_source: dg.tumor_stage_source,
                                        diagnosis: dg.diagnosis
                                    }) ELSE [] END, CASE WHEN collect(sm) <> [] OR collect(dg) <> [] THEN COLLECT(DISTINCT {
                                        sample_anatomic_site: apoc.text.split(sm.anatomic_site, ';'),
                                        participant_age_at_collection: sm.participant_age_at_collection,
                                        sample_tumor_status: sm.sample_tumor_status,
                                        tumor_classification: sm.tumor_classification,
                                        age_at_diagnosis: dg.age_at_diagnosis,
                                        diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                                        disease_phase: dg.disease_phase,
                                        diagnosis_classification_system: dg.diagnosis_classification_system,
                                        diagnosis_category: apoc.text.split(dg.diagnosis_category, ';'),
                                        diagnosis_basis: dg.diagnosis_basis,
                                        tumor_grade_source: dg.tumor_grade_source,
                                        tumor_stage_source: dg.tumor_stage_source,
                                        diagnosis: dg.diagnosis
                                    }) ELSE [] END) as sample_diagnosis_filter_6
          with file, p, apoc.coll.union(sample_diagnosis_filter_5, sample_diagnosis_filter_6) as sample_diagnosis_filter
          MATCH (p)<--(file)
          OPTIONAL MATCH (p)<-[:of_survival]-(su:survival)
          OPTIONAL MATCH (p)<-[:of_treatment]-(tm:treatment)
          OPTIONAL MATCH (p)<-[:of_treatment_response]-(tr:treatment_response)
          with file, p, sample_diagnosis_filter,
            CASE WHEN collect(su) <> [] THEN COLLECT(DISTINCT {last_known_survival_status: su.last_known_survival_status, 
              event_free_survival_status: su.event_free_survival_status, 
              first_event: su.first_event,
              age_at_last_known_survival_status: su.age_at_last_known_survival_status} ) ELSE [] END as survival_filters,
            CASE WHEN collect(tm) <> [] THEN COLLECT(DISTINCT{treatment_type: apoc.text.split(tm.treatment_type, ';'),
            treatment_agent: apoc.text.split(tm.treatment_agent, ';'),
            age_at_treatment_start: tm.age_at_treatment_start}) ELSE [] END as treatment_filters,
            CASE WHEN collect(tr) <> [] THEN COLLECT(DISTINCT{response_category: tr.response_category,
            age_at_response: tr.age_at_response}) ELSE [] END as treatment_response_filters
          with file.dcf_indexd_guid as file_uid, p, sample_diagnosis_filter, survival_filters, treatment_filters, treatment_response_filters
          WITH file_uid, p,
              coalesce(sample_diagnosis_filter, [])    AS sdf,
              coalesce(survival_filters, [])           AS svf,
              coalesce(treatment_filters, [])          AS tf,
              coalesce(treatment_response_filters, []) AS trf
          WITH file_uid, p,
              collect(sdf) AS sdf_lists,
              collect(svf) AS svf_lists,
              collect(tf)  AS tf_lists,
              collect(trf) AS trf_lists
          WITH file_uid, p, {
            participant_id: p.participant_id,
            race: apoc.text.split(p.race, ';'),
            sex_at_birth: p.sex_at_birth,
            sample_diagnosis_filters:    apoc.coll.toSet(apoc.coll.flatten(sdf_lists)),
            survival_filters:           apoc.coll.toSet(apoc.coll.flatten(svf_lists)),
            treatment_filters:          apoc.coll.toSet(apoc.coll.flatten(tf_lists)),
            treatment_response_filters: apoc.coll.toSet(apoc.coll.flatten(trf_lists))
          } AS rowmap
          WITH file_uid, collect(distinct p.id) as pids, collect(distinct p.participant_id) as participant_ids, collect(DISTINCT rowmap) AS combined_filters
          OPTIONAL MATCH (file)-->(:participant)-->(:consent_group)-->(st:study)
          where (file:clinical_measure_file or file: generic_file or file:radiology_file) and file.dcf_indexd_guid = file_uid
          WITH file_uid, pids, participant_ids, combined_filters, head(collect(file)) AS file, head(collect(st)) AS st
          RETURN DISTINCT
            file_uid as id,
            pids as pid,
            file_uid AS file_id,
            file.dcf_indexd_guid AS guid,
            file.file_name AS file_name,
            file.file_access AS file_access,
            apoc.text.split(file.data_category, ';') As data_category,
            file.file_type AS file_type,
            file.file_mapping_level as file_mapping_level,
            file.file_description AS file_description,
            file.file_size AS file_size,
            file.md5sum AS md5sum,
            st.study_id AS study_id,
            st.dbgap_accession as dbgap_accession,
            st.study_status AS study_status,
            st.study_acronym as study_acronym,
            st.study_name as study_name,
            participant_ids AS participant_id,
            null AS sample_id,
            apoc.text.join(participant_ids, ',') as participant_id_gs,
            null as sample_id_gs,
            st.study_id as study_id_gs,
            file.file_description as file_description_gs,
            file.file_type as file_type_gs,
            file.file_name as file_name_gs,
            file.data_category as data_category_gs,
            [file_uid] as files,
            combined_filters as combined_filters,
            null AS library_selection,
            null AS library_source_material,
            null AS library_source_molecule,
            null AS library_strategy
        page_size: 100    
      - query: |
          MATCH (st:study)<-[:of_clinical_measure_file]-(file:clinical_measure_file)
          OPTIONAL MATCH (st)<-[:of_consent_group]-(cg:consent_group)<-[:of_participant]-(p:participant)
          optional MATCH (p)<-[*0..3]-(sm:sample)
          OPTIONAL MATCH (p)<-[:of_diagnosis]-(dg:diagnosis)
          with file, p, case when collect(sm) <> [] OR collect(dg) <> [] THEN COLLECT(DISTINCT {
                                        sample_anatomic_site: apoc.text.split(sm.anatomic_site, ';'),
                                        participant_age_at_collection: sm.participant_age_at_collection,
                                        sample_tumor_status: sm.sample_tumor_status,
                                        tumor_classification: sm.tumor_classification,
                                        age_at_diagnosis: dg.age_at_diagnosis,
                                        diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                                        disease_phase: dg.disease_phase,
                                        diagnosis_classification_system: dg.diagnosis_classification_system,
                                        diagnosis_category: apoc.text.split(dg.diagnosis_category, ';'),
                                        diagnosis_basis: dg.diagnosis_basis,
                                        tumor_grade_source: dg.tumor_grade_source,
                                        tumor_stage_source: dg.tumor_stage_source,
                                        diagnosis: dg.diagnosis
                                    }) ELSE [] END as sample_diagnosis_filter_1
          match (st:study)<-[:of_consent_group]-(cg:consent_group)<-[:of_participant]-(p)
          match (st)<--(file)
          optional MATCH (p)<-[:of_sample]-(sm:sample)
          OPTIONAL MATCH (sm)<--(dg:diagnosis)
          with file, p, sample_diagnosis_filter_1, case when collect(sm) <> [] OR collect(dg) <> [] THEN COLLECT(DISTINCT {
                                        sample_anatomic_site: apoc.text.split(sm.anatomic_site, ';'),
                                        participant_age_at_collection: sm.participant_age_at_collection,
                                        sample_tumor_status: sm.sample_tumor_status,
                                        tumor_classification: sm.tumor_classification,
                                        age_at_diagnosis: dg.age_at_diagnosis,
                                        diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                                        disease_phase: dg.disease_phase,
                                        diagnosis_classification_system: dg.diagnosis_classification_system,
                                        diagnosis_category: apoc.text.split(dg.diagnosis_category, ';'),
                                        diagnosis_basis: dg.diagnosis_basis,
                                        tumor_grade_source: dg.tumor_grade_source,
                                        tumor_stage_source: dg.tumor_stage_source,
                                        diagnosis: dg.diagnosis
                                    }) ELSE [] END as sample_diagnosis_filter_2
          with file, p, apoc.coll.union(sample_diagnosis_filter_1, sample_diagnosis_filter_2) as sample_diagnosis_filter_3
          match (st:study)<-[:of_consent_group]-(cg:consent_group)<-[:of_participant]-(p)
          match (st)<--(file)
          optional MATCH (p)<-[:of_sample]-(sm1:sample)<-[*2..2]-(sm:sample)
          OPTIONAL MATCH (sm1)<--(dg:diagnosis)
          with file, p, sample_diagnosis_filter_3, case when collect(sm) <> [] OR collect(dg) <> [] THEN COLLECT(DISTINCT {
                                        sample_anatomic_site: apoc.text.split(sm.anatomic_site, ';'),
                                        participant_age_at_collection: sm.participant_age_at_collection,
                                        sample_tumor_status: sm.sample_tumor_status,
                                        tumor_classification: sm.tumor_classification,
                                        age_at_diagnosis: dg.age_at_diagnosis,
                                        diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                                        disease_phase: dg.disease_phase,
                                        diagnosis_classification_system: dg.diagnosis_classification_system,
                                        diagnosis_basis: dg.diagnosis_basis,
                                        tumor_grade_source: dg.tumor_grade_source,
                                        tumor_stage_source: dg.tumor_stage_source,
                                        diagnosis: dg.diagnosis,
                                        diagnosis_category: apoc.text.split(dg.diagnosis_category, ';')
                                    }) ELSE [] END as sample_diagnosis_filter_4
          with file, p, apoc.coll.union(sample_diagnosis_filter_3, sample_diagnosis_filter_4) as sample_diagnosis_filter_5
          MATCH (st:study)<-[:of_clinical_measure_file]-(file)
          OPTIONAL MATCH (st)<-[:of_consent_group]-(cg:consent_group)<-[:of_participant]-(p)
          optional MATCH (p)<-[:of_sample]-(sm1:sample)<-[*2..2]-(sm:sample)
          OPTIONAL MATCH (sm)<--(dg:diagnosis)
          OPTIONAL MATCH (p)<-[:of_survival]-(su:survival)
          OPTIONAL MATCH (p)<-[:of_treatment]-(tm:treatment)
          OPTIONAL MATCH (p)<-[:of_treatment_response]-(tr:treatment_response)
          with file, p, sample_diagnosis_filter_5, apoc.coll.union(case when collect(sm1) <> [] OR collect(dg) <> [] THEN COLLECT(DISTINCT {
                                        sample_anatomic_site: apoc.text.split(sm1.anatomic_site, ';'),
                                        participant_age_at_collection: sm1.participant_age_at_collection,
                                        sample_tumor_status: sm1.sample_tumor_status,
                                        tumor_classification: sm1.tumor_classification,
                                        age_at_diagnosis: dg.age_at_diagnosis,
                                        diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                                        disease_phase: dg.disease_phase,
                                        diagnosis_classification_system: dg.diagnosis_classification_system,
                                        diagnosis_basis: dg.diagnosis_basis,
                                        tumor_grade_source: dg.tumor_grade_source,
                                        tumor_stage_source: dg.tumor_stage_source,
                                        diagnosis: dg.diagnosis,
                                        diagnosis_category: apoc.text.split(dg.diagnosis_category, ';')
                                    }) ELSE [] END, case when collect(sm) <> [] AND collect(dg) <> [] THEN COLLECT(DISTINCT {
                                        sample_anatomic_site: apoc.text.split(sm.anatomic_site, ';'),
                                        participant_age_at_collection: sm.participant_age_at_collection,
                                        sample_tumor_status: sm.sample_tumor_status,
                                        tumor_classification: sm.tumor_classification,
                                        age_at_diagnosis: dg.age_at_diagnosis,
                                        diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                                        disease_phase: dg.disease_phase,
                                        diagnosis_classification_system: dg.diagnosis_classification_system,
                                        diagnosis_basis: dg.diagnosis_basis,
                                        tumor_grade_source: dg.tumor_grade_source,
                                        tumor_stage_source: dg.tumor_stage_source,
                                        diagnosis: dg.diagnosis,
                                        diagnosis_category: apoc.text.split(dg.diagnosis_category, ';')
                                    }) ELSE [] END) AS sample_diagnosis_filter_6, 
            case when collect(su) <> [] THEN COLLECT(DISTINCT {last_known_survival_status: su.last_known_survival_status, 
              event_free_survival_status: su.event_free_survival_status, 
              first_event: su.first_event,
              age_at_last_known_survival_status: su.age_at_last_known_survival_status} ) ELSE [] END as survival_filters,
            case when collect(tm) <> [] THEN COLLECT(DISTINCT{treatment_type: apoc.text.split(tm.treatment_type, ';'),
            treatment_agent: apoc.text.split(tm.treatment_agent, ';'),
            age_at_treatment_start: tm.age_at_treatment_start}) ELSE [] END as treatment_filters,
            case when collect(tr) <> [] THEN COLLECT(DISTINCT{response_category: tr.response_category,
            age_at_response: tr.age_at_response}) ELSE [] END as treatment_response_filters
          with file, p, apoc.coll.union(sample_diagnosis_filter_5, sample_diagnosis_filter_6) as sample_diagnosis_filter, survival_filters,  treatment_filters, treatment_response_filters
          with file, collect(DISTINCT {
                participant_id: p.participant_id,
                race: apoc.text.split(p.race, ';'),
                sex_at_birth: p.sex_at_birth,
                sample_diagnosis_filters: sample_diagnosis_filter,
                survival_filters: survival_filters,
                treatment_filters: treatment_filters,
                treatment_response_filters: treatment_response_filters
            }) as combined_filter_1
          MATCH (st:study)<-[:of_clinical_measure_file]-(file)
          OPTIONAL MATCH (st)<--(cl)<--(sm:sample)
          where (cl: cell_line or cl: pdx)
          OPTIONAL MATCH (sm)<--(dg:diagnosis)
          with file, combined_filter_1, case when collect(sm) <> [] OR collect(dg) <> [] THEN COLLECT(DISTINCT {
                                        sample_anatomic_site: apoc.text.split(sm.anatomic_site, ';'),
                                        participant_age_at_collection: sm.participant_age_at_collection,
                                        sample_tumor_status: sm.sample_tumor_status,
                                        tumor_classification: sm.tumor_classification,
                                        age_at_diagnosis: dg.age_at_diagnosis,
                                        diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                                        disease_phase: dg.disease_phase,
                                        diagnosis_classification_system: dg.diagnosis_classification_system,
                                        diagnosis_basis: dg.diagnosis_basis,
                                        tumor_grade_source: dg.tumor_grade_source,
                                        tumor_stage_source: dg.tumor_stage_source,
                                        diagnosis: dg.diagnosis,
                                        diagnosis_category: apoc.text.split(dg.diagnosis_category, ';')
                                    }) ELSE [] END as sample_diagnosis_filter
          with file, combined_filter_1, case when sample_diagnosis_filter <> [] THEN collect({
                participant_id: null,
                race: null,
                sex_at_birth: null,
                sample_diagnosis_filters: sample_diagnosis_filter,
                survival_filters: [],
                treatment_filters: [],
                treatment_response_filters: []
          }) ELSE [] END as combined_filter_2
          with file, apoc.coll.union(combined_filter_1, combined_filter_2) as combined_filter
          MATCH (st:study)<-[:of_clinical_measure_file]-(file)
          With file, st, combined_filter
          RETURN DISTINCT
            file.dcf_indexd_guid as id,
            [] as pid,
            file.dcf_indexd_guid AS file_id,
            file.dcf_indexd_guid AS guid,
            file.file_name AS file_name,
            file.file_access AS file_access,
            apoc.text.split(file.data_category, ';') as data_category,
            file.file_type AS file_type,
            file.file_mapping_level as file_mapping_level,
            file.file_description AS file_description,
            file.file_size AS file_size,
            file.md5sum AS md5sum,
            st.study_id AS study_id,
            st.dbgap_accession as dbgap_accession,
            st.study_status AS study_status,
            st.study_acronym as study_acronym,
            st.study_name as study_name,
            null AS participant_id,
            null AS sample_id,
            null as participant_id_gs,
            null as sample_id_gs,
            st.study_id as study_id_gs,
            file.file_description as file_description_gs,
            file.file_type as file_type_gs,
            file.file_name as file_name_gs,
            file.data_category as data_category_gs,
            [file.dcf_indexd_guid] as files,
            combined_filter as combined_filters,
            null AS library_selection,
            null AS library_source_material,
            null AS library_source_molecule,
            null AS library_strategy
      - query: |
          MATCH (st:study)<-[:of_generic_file]-(file:generic_file)
          with file
          skip $skip limit $limit
          MATCH (st:study)<-[:of_generic_file]-(file)
          OPTIONAL MATCH (st)<-[:of_consent_group]-(cg:consent_group)<-[:of_participant]-(p)
          optional MATCH (p)<-[*0..3]-(sm:sample)
          OPTIONAL MATCH (p)<-[:of_diagnosis]-(dg:diagnosis)
          with file, p, case when collect(sm) <> [] OR collect(dg) <> [] THEN COLLECT(DISTINCT {
                                        sample_anatomic_site: apoc.text.split(sm.anatomic_site, ';'),
                                        participant_age_at_collection: sm.participant_age_at_collection,
                                        sample_tumor_status: sm.sample_tumor_status,
                                        tumor_classification: sm.tumor_classification,
                                        age_at_diagnosis: dg.age_at_diagnosis,
                                        diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                                        disease_phase: dg.disease_phase,
                                        diagnosis_classification_system: dg.diagnosis_classification_system,
                                        diagnosis_category: apoc.text.split(dg.diagnosis_category, ';'),
                                        diagnosis_basis: dg.diagnosis_basis,
                                        tumor_grade_source: dg.tumor_grade_source,
                                        tumor_stage_source: dg.tumor_stage_source,
                                        diagnosis: dg.diagnosis
                                    }) ELSE [] END as sample_diagnosis_filter_1
          match (st:study)<-[:of_consent_group]-(cg:consent_group)<-[:of_participant]-(p)
          match (st)<--(file)
          optional MATCH (p)<-[:of_sample]-(sm:sample)
          OPTIONAL MATCH (sm)<--(dg:diagnosis)
          with file, p, sample_diagnosis_filter_1, case when collect(sm) <> [] OR collect(dg) <> [] THEN COLLECT(DISTINCT {
                                        sample_anatomic_site: apoc.text.split(sm.anatomic_site, ';'),
                                        participant_age_at_collection: sm.participant_age_at_collection,
                                        sample_tumor_status: sm.sample_tumor_status,
                                        tumor_classification: sm.tumor_classification,
                                        age_at_diagnosis: dg.age_at_diagnosis,
                                        diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                                        disease_phase: dg.disease_phase,
                                        diagnosis_classification_system: dg.diagnosis_classification_system,
                                        diagnosis_category: apoc.text.split(dg.diagnosis_category, ';'),
                                        diagnosis_basis: dg.diagnosis_basis,
                                        tumor_grade_source: dg.tumor_grade_source,
                                        tumor_stage_source: dg.tumor_stage_source,
                                        diagnosis: dg.diagnosis
                                    }) ELSE [] END as sample_diagnosis_filter_2
          with file, p, apoc.coll.union(sample_diagnosis_filter_1, sample_diagnosis_filter_2) as sample_diagnosis_filter_3
          match (st:study)<-[:of_consent_group]-(cg:consent_group)<-[:of_participant]-(p)
          match (st)<--(file)
          optional MATCH (p)<-[:of_sample]-(sm1:sample)<-[*2..2]-(sm:sample)
          OPTIONAL MATCH (sm1)<--(dg:diagnosis)
          with file, p, sample_diagnosis_filter_3, case when collect(sm) <> [] OR collect(dg) <> [] THEN COLLECT(DISTINCT {
                                        sample_anatomic_site: apoc.text.split(sm.anatomic_site, ';'),
                                        participant_age_at_collection: sm.participant_age_at_collection,
                                        sample_tumor_status: sm.sample_tumor_status,
                                        tumor_classification: sm.tumor_classification,
                                        age_at_diagnosis: dg.age_at_diagnosis,
                                        diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                                        disease_phase: dg.disease_phase,
                                        diagnosis_classification_system: dg.diagnosis_classification_system,
                                        diagnosis_category: apoc.text.split(dg.diagnosis_category, ';'),
                                        diagnosis_basis: dg.diagnosis_basis,
                                        tumor_grade_source: dg.tumor_grade_source,
                                        tumor_stage_source: dg.tumor_stage_source,
                                        diagnosis: dg.diagnosis
                                    }) ELSE [] END as sample_diagnosis_filter_4
          with file, p, apoc.coll.union(sample_diagnosis_filter_3, sample_diagnosis_filter_4) as sample_diagnosis_filter_5
          MATCH (st:study)<-[:of_generic_file]-(file)
          OPTIONAL MATCH (st)<-[:of_consent_group]-(cg:consent_group)<-[:of_participant]-(p)
          optional MATCH (p)<-[:of_sample]-(sm1:sample)<-[*2..2]-(sm:sample)
          OPTIONAL MATCH (sm)<--(dg:diagnosis)
          OPTIONAL MATCH (p)<-[:of_survival]-(su:survival)
          OPTIONAL MATCH (p)<-[:of_treatment]-(tm:treatment)
          OPTIONAL MATCH (p)<-[:of_treatment_response]-(tr:treatment_response)
          with file, p, sample_diagnosis_filter_5, apoc.coll.union(case when collect(sm1) <> [] OR collect(dg) <> [] THEN COLLECT(DISTINCT {
                                        sample_anatomic_site: apoc.text.split(sm1.anatomic_site, ';'),
                                        participant_age_at_collection: sm1.participant_age_at_collection,
                                        sample_tumor_status: sm1.sample_tumor_status,
                                        tumor_classification: sm1.tumor_classification,
                                        age_at_diagnosis: dg.age_at_diagnosis,
                                        diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                                        disease_phase: dg.disease_phase,
                                        diagnosis_classification_system: dg.diagnosis_classification_system,                                        
                                        diagnosis_basis: dg.diagnosis_basis,
                                        tumor_grade_source: dg.tumor_grade_source,
                                        tumor_stage_source: dg.tumor_stage_source,
                                        diagnosis: dg.diagnosis,
                                        diagnosis_category: apoc.text.split(dg.diagnosis_category, ';')
                                    }) ELSE [] END, case when collect(sm) <> [] OR collect(dg) <> [] THEN COLLECT(DISTINCT {
                                        sample_anatomic_site: apoc.text.split(sm.anatomic_site, ';'),
                                        participant_age_at_collection: sm.participant_age_at_collection,
                                        sample_tumor_status: sm.sample_tumor_status,
                                        tumor_classification: sm.tumor_classification,
                                        age_at_diagnosis: dg.age_at_diagnosis,
                                        diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                                        disease_phase: dg.disease_phase,
                                        diagnosis_classification_system: dg.diagnosis_classification_system,
                                        diagnosis_category: apoc.text.split(dg.diagnosis_category, ';'),
                                        diagnosis_basis: dg.diagnosis_basis,
                                        tumor_grade_source: dg.tumor_grade_source,
                                        tumor_stage_source: dg.tumor_stage_source,
                                        diagnosis: dg.diagnosis
                                    }) ELSE [] END) AS sample_diagnosis_filter_6,
            case when collect(su) <> [] THEN COLLECT(DISTINCT {last_known_survival_status: su.last_known_survival_status, 
              event_free_survival_status: su.event_free_survival_status, 
              first_event: su.first_event,
              age_at_last_known_survival_status: su.age_at_last_known_survival_status} ) ELSE [] END as survival_filters,
            case when collect(tm) <> [] THEN COLLECT(DISTINCT{treatment_type: apoc.text.split(tm.treatment_type, ';'),
            treatment_agent: apoc.text.split(tm.treatment_agent, ';'),
            age_at_treatment_start: tm.age_at_treatment_start}) ELSE [] END as treatment_filters,
            case when collect(tr) <> [] THEN COLLECT(DISTINCT{response_category: tr.response_category,
            age_at_response: tr.age_at_response}) ELSE [] END as treatment_response_filters
          with file, p, apoc.coll.union(sample_diagnosis_filter_5, sample_diagnosis_filter_6) as sample_diagnosis_filter, survival_filters,  treatment_filters, treatment_response_filters
          with file, collect(DISTINCT {
                participant_id: p.participant_id,
                race: apoc.text.split(p.race, ';'),
                sex_at_birth: p.sex_at_birth,
                sample_diagnosis_filters: sample_diagnosis_filter,
                survival_filters: survival_filters,
                treatment_filters: treatment_filters,
                treatment_response_filters: treatment_response_filters
            }) as combined_filter_1
          MATCH (st:study)<-[:of_generic_file]-(file)
          OPTIONAL MATCH (st)<--(cl)<--(sm:sample)
          where (cl: cell_line or cl: pdx)
          OPTIONAL MATCH (sm)<--(dg:diagnosis)
          with file, combined_filter_1, case when collect(sm) <> [] OR collect(dg) <> [] THEN COLLECT(DISTINCT {
                                        sample_anatomic_site: apoc.text.split(sm.anatomic_site, ';'),
                                        participant_age_at_collection: sm.participant_age_at_collection,
                                        sample_tumor_status: sm.sample_tumor_status,
                                        tumor_classification: sm.tumor_classification,
                                        age_at_diagnosis: dg.age_at_diagnosis,
                                        diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                                        disease_phase: dg.disease_phase,
                                        diagnosis_classification_system: dg.diagnosis_classification_system,
                                        diagnosis_basis: dg.diagnosis_basis,
                                        tumor_grade_source: dg.tumor_grade_source,
                                        tumor_stage_source: dg.tumor_stage_source,
                                        diagnosis: dg.diagnosis,
                                        diagnosis_category: apoc.text.split(dg.diagnosis_category, ';')
                                    }) ELSE [] END as sample_diagnosis_filter
          with file, combined_filter_1, case when sample_diagnosis_filter <> [] THEN collect({
                participant_id: null,
                race: null,
                sex_at_birth: null,
                sample_diagnosis_filters: sample_diagnosis_filter,
                survival_filters: [],
                treatment_filters: [],
                treatment_response_filters: []
          }) ELSE [] END as combined_filter_2
          with file, apoc.coll.union(combined_filter_1, combined_filter_2) as combined_filter
          MATCH (st:study)<-[:of_generic_file]-(file)
          With file, st, combined_filter
          RETURN DISTINCT
            file.dcf_indexd_guid as id,
            [] as pid,
            file.dcf_indexd_guid AS file_id,
            file.dcf_indexd_guid AS guid,
            file.file_name AS file_name,
            file.file_access AS file_access,
            apoc.text.split(file.data_category, ';') as data_category,
            file.file_type AS file_type,
            file.file_mapping_level as file_mapping_level,
            file.file_description AS file_description,
            file.file_size AS file_size,
            file.md5sum AS md5sum,
            st.study_id AS study_id,
            st.dbgap_accession as dbgap_accession,
            st.study_status AS study_status,
            st.study_acronym as study_acronym,
            st.study_name as study_name,
            null AS participant_id,
            null AS sample_id,
            null as participant_id_gs,
            null as sample_id_gs,
            st.study_id as study_id_gs,
            file.file_description as file_description_gs,
            file.file_type as file_type_gs,
            file.file_name as file_name_gs,
            file.data_category as data_category_gs,
            [file.dcf_indexd_guid] as files,
            combined_filter as combined_filters,
            null AS library_selection,
            null AS library_source_material,
            null AS library_source_molecule,
            null AS library_strategy
        page_size: 5
      - query: |
          MATCH (file: sequencing_file)
          MATCH (st:study)<-[*..5]-(sm:sample)<--(file)
          with distinct file.dcf_indexd_guid as file_guid
          SKIP $skip LIMIT $limit
          MATCH (file: sequencing_file {dcf_indexd_guid: file_guid})
          optional MATCH (p:participant)<-[*..3]-(sm:sample)<--(file)
          OPTIONAL MATCH (p)<-[:of_diagnosis]-(dg:diagnosis)
          with file, case when collect(sm) <> [] OR collect(dg) <> [] THEN COLLECT(DISTINCT {
                                        sample_anatomic_site: apoc.text.split(sm.anatomic_site, ';'),
                                        participant_age_at_collection: sm.participant_age_at_collection,
                                        sample_tumor_status: sm.sample_tumor_status,
                                        tumor_classification: sm.tumor_classification,
                                        age_at_diagnosis: dg.age_at_diagnosis,
                                        diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                                        disease_phase: dg.disease_phase,
                                        diagnosis_classification_system: dg.diagnosis_classification_system,
                                        diagnosis_category: apoc.text.split(dg.diagnosis_category, ';'),
                                        diagnosis_basis: dg.diagnosis_basis,
                                        tumor_grade_source: dg.tumor_grade_source,
                                        tumor_stage_source: dg.tumor_stage_source,
                                        diagnosis: dg.diagnosis
                                    }) ELSE [] END as sample_diagnosis_filter_1
          optional MATCH (p:participant)<-[:of_sample]-(sm:sample)<--(file)
          OPTIONAL MATCH (sm)<--(dg:diagnosis)
          with file, sample_diagnosis_filter_1, case when collect(sm) <> [] OR collect(dg) <> [] THEN COLLECT(DISTINCT {
                                        sample_anatomic_site: apoc.text.split(sm.anatomic_site, ';'),
                                        participant_age_at_collection: sm.participant_age_at_collection,
                                        sample_tumor_status: sm.sample_tumor_status,
                                        tumor_classification: sm.tumor_classification,
                                        age_at_diagnosis: dg.age_at_diagnosis,
                                        diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                                        disease_phase: dg.disease_phase,
                                        diagnosis_classification_system: dg.diagnosis_classification_system,
                                        diagnosis_category: apoc.text.split(dg.diagnosis_category, ';'),
                                        diagnosis_basis: dg.diagnosis_basis,
                                        tumor_grade_source: dg.tumor_grade_source,
                                        tumor_stage_source: dg.tumor_stage_source,
                                        diagnosis: dg.diagnosis
                                    }) ELSE [] END as sample_diagnosis_filter_2
          with file, apoc.coll.union(sample_diagnosis_filter_1, sample_diagnosis_filter_2) as sample_diagnosis_filter_3
          optional MATCH (p:participant)<-[:of_sample]-(sm1:sample)<-[*2..2]-(sm:sample)<--(file)
          OPTIONAL MATCH (sm1)<--(dg:diagnosis)
          with file, sample_diagnosis_filter_3, apoc.coll.union( case when collect(sm1) <> [] OR collect(dg) <> [] THEN COLLECT(DISTINCT {
                                        sample_anatomic_site: apoc.text.split(sm1.anatomic_site, ';'),
                                        participant_age_at_collection: sm1.participant_age_at_collection,
                                        sample_tumor_status: sm1.sample_tumor_status,
                                        tumor_classification: sm1.tumor_classification,
                                        age_at_diagnosis: dg.age_at_diagnosis,
                                        diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                                        disease_phase: dg.disease_phase,
                                        diagnosis_classification_system: dg.diagnosis_classification_system,
                                        diagnosis_basis: dg.diagnosis_basis,
                                        tumor_grade_source: dg.tumor_grade_source,
                                        tumor_stage_source: dg.tumor_stage_source,
                                        diagnosis: dg.diagnosis,
                                        diagnosis_category: apoc.text.split(dg.diagnosis_category, ';')
                                    }) ELSE [] END, case when collect(sm) <> [] OR collect(dg) <> [] THEN COLLECT(DISTINCT {
                                        sample_anatomic_site: apoc.text.split(sm.anatomic_site, ';'),
                                        participant_age_at_collection: sm.participant_age_at_collection,
                                        sample_tumor_status: sm.sample_tumor_status,
                                        tumor_classification: sm.tumor_classification,
                                        age_at_diagnosis: dg.age_at_diagnosis,
                                        diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                                        disease_phase: dg.disease_phase,
                                        diagnosis_classification_system: dg.diagnosis_classification_system,  
                                        diagnosis_basis: dg.diagnosis_basis,
                                        tumor_grade_source: dg.tumor_grade_source,
                                        tumor_stage_source: dg.tumor_stage_source,
                                        diagnosis: dg.diagnosis,
                                        diagnosis_category: apoc.text.split(dg.diagnosis_category, ';')
                                    }) ELSE [] END) AS sample_diagnosis_filter_4
          with file, apoc.coll.union(sample_diagnosis_filter_3, sample_diagnosis_filter_4) as sample_diagnosis_filter_5
          optional MATCH (p:participant)<-[:of_sample]-(sm1:sample)<-[*2..2]-(sm:sample)<--(file)
          OPTIONAL MATCH (sm)<--(dg:diagnosis)
          with file, sample_diagnosis_filter_5, apoc.coll.union(case when collect(sm1) <> [] OR collect(dg) <> [] THEN COLLECT(DISTINCT {
                                        sample_anatomic_site: apoc.text.split(sm1.anatomic_site, ';'),
                                        participant_age_at_collection: sm1.participant_age_at_collection,
                                        sample_tumor_status: sm1.sample_tumor_status,
                                        tumor_classification: sm1.tumor_classification,
                                        age_at_diagnosis: dg.age_at_diagnosis,
                                        diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                                        disease_phase: dg.disease_phase,
                                        diagnosis_classification_system: dg.diagnosis_classification_system,
                                        diagnosis_basis: dg.diagnosis_basis,
                                        tumor_grade_source: dg.tumor_grade_source,
                                        tumor_stage_source: dg.tumor_stage_source,
                                        diagnosis: dg.diagnosis,
                                        diagnosis_category: apoc.text.split(dg.diagnosis_category, ';')
                                    }) ELSE [] END, case when collect(sm) <> [] OR collect(dg) <> [] THEN COLLECT(DISTINCT {
                                        sample_anatomic_site: apoc.text.split(sm.anatomic_site, ';'),
                                        participant_age_at_collection: sm.participant_age_at_collection,
                                        sample_tumor_status: sm.sample_tumor_status,
                                        tumor_classification: sm.tumor_classification,
                                        age_at_diagnosis: dg.age_at_diagnosis,
                                        diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                                        disease_phase: dg.disease_phase,
                                        diagnosis_classification_system: dg.diagnosis_classification_system,
                                        diagnosis_basis: dg.diagnosis_basis,
                                        tumor_grade_source: dg.tumor_grade_source,
                                        tumor_stage_source: dg.tumor_stage_source,
                                        diagnosis: dg.diagnosis,
                                        diagnosis_category: apoc.text.split(dg.diagnosis_category, ';')
                                    }) ELSE [] END) AS sample_diagnosis_filter_6
          with file, apoc.coll.union(sample_diagnosis_filter_5, sample_diagnosis_filter_6) as sample_diagnosis_filter
          optional MATCH (st:study)<-[:of_cell_line|of_pdx]-(cl)<--(sm:sample)<--(file)
          Where (cl: cell_line or cl: pdx)
          optional match (sm)<--(dg:diagnosis)
          with file, sample_diagnosis_filter, case when collect(sm) <> [] OR collect(dg) <> [] THEN COLLECT(DISTINCT {
                                        sample_anatomic_site: apoc.text.split(sm.anatomic_site, ';'),
                                        participant_age_at_collection: sm.participant_age_at_collection,
                                        sample_tumor_status: sm.sample_tumor_status,
                                        tumor_classification: sm.tumor_classification,
                                        age_at_diagnosis: dg.age_at_diagnosis,
                                        diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                                        disease_phase: dg.disease_phase,
                                        diagnosis_classification_system: dg.diagnosis_classification_system,
                                        diagnosis_category: apoc.text.split(dg.diagnosis_category, ';'),
                                        diagnosis_basis: dg.diagnosis_basis,
                                        tumor_grade_source: dg.tumor_grade_source,
                                        tumor_stage_source: dg.tumor_stage_source,
                                        diagnosis: dg.diagnosis
                                    }) ELSE [] END as sample_diagnosis_filter_1
          with file, apoc.coll.union(sample_diagnosis_filter_1, sample_diagnosis_filter) as sample_diagnosis_filter
          optional MATCH (p:participant)<-[:of_sample]-(sm1:sample)<-[*0..2]-(sm:sample)<--(file)
          OPTIONAL MATCH (p)<-[:of_survival]-(su:survival)
          OPTIONAL MATCH (p)<-[:of_treatment]-(tm:treatment)
          OPTIONAL MATCH (p)<-[:of_treatment_response]-(tr:treatment_response)
          optional MATCH (st:study)<-[:of_cell_line|of_pdx]-(cl)<--(sm2:sample)<--(file)
          Where (cl: cell_line or cl: pdx)
          with file, p, sm2, sm1, sm, sample_diagnosis_filter,
            case when collect(su) <> [] THEN COLLECT(DISTINCT {last_known_survival_status: su.last_known_survival_status, 
              event_free_survival_status: su.event_free_survival_status, 
              first_event: su.first_event,
              age_at_last_known_survival_status: su.age_at_last_known_survival_status} ) ELSE [] END as survival_filters,
            case when collect(tm) <> [] THEN COLLECT(DISTINCT{treatment_type: apoc.text.split(tm.treatment_type, ';'),
            treatment_agent: apoc.text.split(tm.treatment_agent, ';'),
            age_at_treatment_start: tm.age_at_treatment_start}) ELSE [] END as treatment_filters,
            case when collect(tr) <> [] THEN COLLECT(DISTINCT{response_category: tr.response_category,
            age_at_response: tr.age_at_response}) ELSE [] END as treatment_response_filters
          with file.dcf_indexd_guid as file_uid, p, sm2, sm1, sm, sample_diagnosis_filter, survival_filters, treatment_filters, treatment_response_filters
          WITH file_uid, p, sm2, sm1, sm,
              coalesce(sample_diagnosis_filter, [])    AS sdf,
              coalesce(survival_filters, [])           AS svf,
              coalesce(treatment_filters, [])          AS tf,
              coalesce(treatment_response_filters, []) AS trf
          WITH file_uid, p, collect([sm2.sample_id,sm1.sample_id,sm.sample_id]) AS sample_ids,
              collect(sdf) AS sdf_lists,
              collect(svf) AS svf_lists,
              collect(tf)  AS tf_lists,
              collect(trf) AS trf_lists
          WITH file_uid, p, apoc.coll.toSet(apoc.coll.flatten(sample_ids)) as sids, case when p IS NOT NULL THEN {
            participant_id: p.participant_id,
            race: apoc.text.split(p.race, ';'),
            sex_at_birth: p.sex_at_birth,
            sample_diagnosis_filters:    apoc.coll.toSet(apoc.coll.flatten(sdf_lists)),
            survival_filters:           apoc.coll.toSet(apoc.coll.flatten(svf_lists)),
            treatment_filters:          apoc.coll.toSet(apoc.coll.flatten(tf_lists)),
            treatment_response_filters: apoc.coll.toSet(apoc.coll.flatten(trf_lists))
          } ELSE {
            participant_id: null,
            race: null,
            sex_at_birth: null,
            sample_diagnosis_filters: apoc.coll.toSet(apoc.coll.flatten(sdf_lists)),
            survival_filters: [],
            treatment_filters: [],
            treatment_response_filters: []
          } END AS rowmap
          WITH file_uid, collect(distinct p.id) as pids, collect(distinct p.participant_id) as participant_ids, apoc.coll.toSet(apoc.coll.flatten(collect(distinct sids))) as sample_ids, collect(DISTINCT rowmap) AS combined_filters
          OPTIONAL MATCH (sm:sample)<--(file: sequencing_file {dcf_indexd_guid: file_uid})
          WITH file_uid, pids, participant_ids, [v IN sample_ids WHERE v IS NOT NULL] as sample_ids, combined_filters, head(collect(file)) AS file
          optional match (file)-[*..8]->(st:study)
          with file_uid, pids, participant_ids, [v IN sample_ids WHERE v IS NOT NULL] as sample_ids, combined_filters, file, st
          RETURN DISTINCT
            file_uid as id,
            pids as pid,
            file_uid AS file_id,
            file.dcf_indexd_guid AS guid,
            file.file_name AS file_name,
            file.file_access AS file_access,
            apoc.text.split(file.data_category, ';') As data_category,
            file.file_type AS file_type,
            file.file_mapping_level as file_mapping_level,
            file.file_description AS file_description,
            file.file_size AS file_size,
            file.md5sum AS md5sum,
            st.study_id AS study_id,
            st.dbgap_accession as dbgap_accession,
            st.study_status AS study_status,
            st.study_acronym as study_acronym,
            st.study_name as study_name,
            participant_ids AS participant_id,
            sample_ids AS sample_id,
            apoc.text.join(participant_ids, ',') as participant_id_gs,
            apoc.text.join(sample_ids, ',') as sample_id_gs,
            st.study_id as study_id_gs,
            file.file_description as file_description_gs,
            file.file_type as file_type_gs,
            file.file_name as file_name_gs,
            file.data_category as data_category_gs,
            [file_uid] as files,
            combined_filters as combined_filters,
            file.library_selection AS library_selection,
            file.library_source_material AS library_source_material,
            file.library_source_molecule AS library_source_molecule,
            file.library_strategy AS library_strategy
        page_size: 1000 
      - query: |
          MATCH (file)
          where (file: generic_file OR file:pathology_file OR file:methylation_array_file OR file:cytogenomic_file)
          MATCH (st:study)<-[*..5]-(sm:sample)<--(file)
          with distinct file.dcf_indexd_guid as file_guid
          SKIP $skip LIMIT $limit
          MATCH (file)
          where (file: generic_file OR file:pathology_file OR file:methylation_array_file OR file:cytogenomic_file) and file.dcf_indexd_guid = file_guid
          optional MATCH (p:participant)<-[*..3]-(sm:sample)<--(file)
          OPTIONAL MATCH (p)<-[:of_diagnosis]-(dg:diagnosis)
          with file, case when collect(sm) <> [] OR collect(dg) <> [] THEN COLLECT(DISTINCT {
                                        sample_anatomic_site: apoc.text.split(sm.anatomic_site, ';'),
                                        participant_age_at_collection: sm.participant_age_at_collection,
                                        sample_tumor_status: sm.sample_tumor_status,
                                        tumor_classification: sm.tumor_classification,
                                        age_at_diagnosis: dg.age_at_diagnosis,
                                        diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                                        disease_phase: dg.disease_phase,
                                        diagnosis_classification_system: dg.diagnosis_classification_system,
                                        diagnosis_category: apoc.text.split(dg.diagnosis_category, ';'),
                                        diagnosis_basis: dg.diagnosis_basis,
                                        tumor_grade_source: dg.tumor_grade_source,
                                        tumor_stage_source: dg.tumor_stage_source,
                                        diagnosis: dg.diagnosis
                                    }) ELSE [] END as sample_diagnosis_filter_1
          optional MATCH (p:participant)<-[:of_sample]-(sm:sample)<--(file)
          OPTIONAL MATCH (sm)<--(dg:diagnosis)
          with file, sample_diagnosis_filter_1, case when collect(sm) <> [] OR collect(dg) <> [] THEN COLLECT(DISTINCT {
                                        sample_anatomic_site: apoc.text.split(sm.anatomic_site, ';'),
                                        participant_age_at_collection: sm.participant_age_at_collection,
                                        sample_tumor_status: sm.sample_tumor_status,
                                        tumor_classification: sm.tumor_classification,
                                        age_at_diagnosis: dg.age_at_diagnosis,
                                        diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                                        disease_phase: dg.disease_phase,
                                        diagnosis_classification_system: dg.diagnosis_classification_system,
                                        diagnosis_category: apoc.text.split(dg.diagnosis_category, ';'),
                                        diagnosis_basis: dg.diagnosis_basis,
                                        tumor_grade_source: dg.tumor_grade_source,
                                        tumor_stage_source: dg.tumor_stage_source,
                                        diagnosis: dg.diagnosis
                                    }) ELSE [] END as sample_diagnosis_filter_2
          with file, apoc.coll.union(sample_diagnosis_filter_1, sample_diagnosis_filter_2) as sample_diagnosis_filter_3
          optional MATCH (p:participant)<-[:of_sample]-(sm1:sample)<-[*2..2]-(sm:sample)<--(file)
          OPTIONAL MATCH (sm1)<--(dg:diagnosis)
          with file, sample_diagnosis_filter_3, apoc.coll.union( case when collect(sm1) <> [] OR collect(dg) <> [] THEN COLLECT(DISTINCT {
                                        sample_anatomic_site: apoc.text.split(sm1.anatomic_site, ';'),
                                        participant_age_at_collection: sm1.participant_age_at_collection,
                                        sample_tumor_status: sm1.sample_tumor_status,
                                        tumor_classification: sm1.tumor_classification,
                                        age_at_diagnosis: dg.age_at_diagnosis,
                                        diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                                        disease_phase: dg.disease_phase,
                                        diagnosis_classification_system: dg.diagnosis_classification_system,
                                        diagnosis_basis: dg.diagnosis_basis,
                                        tumor_grade_source: dg.tumor_grade_source,
                                        tumor_stage_source: dg.tumor_stage_source,
                                        diagnosis: dg.diagnosis,
                                        diagnosis_category: apoc.text.split(dg.diagnosis_category, ';')
                                    }) ELSE [] END, case when collect(sm) <> [] OR collect(dg) <> [] THEN COLLECT(DISTINCT {
                                        sample_anatomic_site: apoc.text.split(sm.anatomic_site, ';'),
                                        participant_age_at_collection: sm.participant_age_at_collection,
                                        sample_tumor_status: sm.sample_tumor_status,
                                        tumor_classification: sm.tumor_classification,
                                        age_at_diagnosis: dg.age_at_diagnosis,
                                        diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                                        disease_phase: dg.disease_phase,
                                        diagnosis_classification_system: dg.diagnosis_classification_system,  
                                        diagnosis_basis: dg.diagnosis_basis,
                                        tumor_grade_source: dg.tumor_grade_source,
                                        tumor_stage_source: dg.tumor_stage_source,
                                        diagnosis: dg.diagnosis,
                                        diagnosis_category: apoc.text.split(dg.diagnosis_category, ';')
                                    }) ELSE [] END) AS sample_diagnosis_filter_4
          with file, apoc.coll.union(sample_diagnosis_filter_3, sample_diagnosis_filter_4) as sample_diagnosis_filter_5
          optional MATCH (p:participant)<-[:of_sample]-(sm1:sample)<-[*2..2]-(sm:sample)<--(file)
          OPTIONAL MATCH (sm)<--(dg:diagnosis)
          with file, sample_diagnosis_filter_5, apoc.coll.union(case when collect(sm1) <> [] OR collect(dg) <> [] THEN COLLECT(DISTINCT {
                                        sample_anatomic_site: apoc.text.split(sm1.anatomic_site, ';'),
                                        participant_age_at_collection: sm1.participant_age_at_collection,
                                        sample_tumor_status: sm1.sample_tumor_status,
                                        tumor_classification: sm1.tumor_classification,
                                        age_at_diagnosis: dg.age_at_diagnosis,
                                        diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                                        disease_phase: dg.disease_phase,
                                        diagnosis_classification_system: dg.diagnosis_classification_system,
                                        diagnosis_basis: dg.diagnosis_basis,
                                        tumor_grade_source: dg.tumor_grade_source,
                                        tumor_stage_source: dg.tumor_stage_source,
                                        diagnosis: dg.diagnosis,
                                        diagnosis_category: apoc.text.split(dg.diagnosis_category, ';')
                                    }) ELSE [] END, case when collect(sm) <> [] OR collect(dg) <> [] THEN COLLECT(DISTINCT {
                                        sample_anatomic_site: apoc.text.split(sm.anatomic_site, ';'),
                                        participant_age_at_collection: sm.participant_age_at_collection,
                                        sample_tumor_status: sm.sample_tumor_status,
                                        tumor_classification: sm.tumor_classification,
                                        age_at_diagnosis: dg.age_at_diagnosis,
                                        diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                                        disease_phase: dg.disease_phase,
                                        diagnosis_classification_system: dg.diagnosis_classification_system,
                                        diagnosis_basis: dg.diagnosis_basis,
                                        tumor_grade_source: dg.tumor_grade_source,
                                        tumor_stage_source: dg.tumor_stage_source,
                                        diagnosis: dg.diagnosis,
                                        diagnosis_category: apoc.text.split(dg.diagnosis_category, ';')
                                    }) ELSE [] END) AS sample_diagnosis_filter_6
          with file, apoc.coll.union(sample_diagnosis_filter_5, sample_diagnosis_filter_6) as sample_diagnosis_filter
          optional MATCH (st:study)<-[:of_cell_line|of_pdx]-(cl)<--(sm:sample)<--(file)
          Where (cl: cell_line or cl: pdx)
          optional match (sm)<--(dg:diagnosis)
          with file, sample_diagnosis_filter, case when collect(sm) <> [] OR collect(dg) <> [] THEN COLLECT(DISTINCT {
                                        sample_anatomic_site: apoc.text.split(sm.anatomic_site, ';'),
                                        participant_age_at_collection: sm.participant_age_at_collection,
                                        sample_tumor_status: sm.sample_tumor_status,
                                        tumor_classification: sm.tumor_classification,
                                        age_at_diagnosis: dg.age_at_diagnosis,
                                        diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                                        disease_phase: dg.disease_phase,
                                        diagnosis_classification_system: dg.diagnosis_classification_system,
                                        diagnosis_category: apoc.text.split(dg.diagnosis_category, ';'),
                                        diagnosis_basis: dg.diagnosis_basis,
                                        tumor_grade_source: dg.tumor_grade_source,
                                        tumor_stage_source: dg.tumor_stage_source,
                                        diagnosis: dg.diagnosis
                                    }) ELSE [] END as sample_diagnosis_filter_1
          with file, apoc.coll.union(sample_diagnosis_filter_1, sample_diagnosis_filter) as sample_diagnosis_filter
          optional MATCH (p:participant)<-[:of_sample]-(sm1:sample)<-[*0..2]-(sm:sample)<--(file)
          OPTIONAL MATCH (p)<-[:of_survival]-(su:survival)
          OPTIONAL MATCH (p)<-[:of_treatment]-(tm:treatment)
          OPTIONAL MATCH (p)<-[:of_treatment_response]-(tr:treatment_response)
          optional MATCH (st:study)<-[:of_cell_line|of_pdx]-(cl)<--(sm2:sample)<--(file)
          Where (cl: cell_line or cl: pdx)
          with file, p, sm2, sm1, sm, sample_diagnosis_filter,
            case when collect(su) <> [] THEN COLLECT(DISTINCT {last_known_survival_status: su.last_known_survival_status, 
              event_free_survival_status: su.event_free_survival_status, 
              first_event: su.first_event,
              age_at_last_known_survival_status: su.age_at_last_known_survival_status} ) ELSE [] END as survival_filters,
            case when collect(tm) <> [] THEN COLLECT(DISTINCT{treatment_type: apoc.text.split(tm.treatment_type, ';'),
            treatment_agent: apoc.text.split(tm.treatment_agent, ';'),
            age_at_treatment_start: tm.age_at_treatment_start}) ELSE [] END as treatment_filters,
            case when collect(tr) <> [] THEN COLLECT(DISTINCT{response_category: tr.response_category,
            age_at_response: tr.age_at_response}) ELSE [] END as treatment_response_filters
          with file.dcf_indexd_guid as file_uid, p, sm2, sm1, sm, sample_diagnosis_filter, survival_filters, treatment_filters, treatment_response_filters
          WITH file_uid, p, sm2, sm1, sm,
              coalesce(sample_diagnosis_filter, [])    AS sdf,
              coalesce(survival_filters, [])           AS svf,
              coalesce(treatment_filters, [])          AS tf,
              coalesce(treatment_response_filters, []) AS trf
          WITH file_uid, p, collect([sm2.sample_id,sm1.sample_id,sm.sample_id]) AS sample_ids,
              collect(sdf) AS sdf_lists,
              collect(svf) AS svf_lists,
              collect(tf)  AS tf_lists,
              collect(trf) AS trf_lists
          WITH file_uid, p, apoc.coll.toSet(apoc.coll.flatten(sample_ids)) as sids, case when p IS NOT NULL THEN {
            participant_id: p.participant_id,
            race: apoc.text.split(p.race, ';'),
            sex_at_birth: p.sex_at_birth,
            sample_diagnosis_filters:    apoc.coll.toSet(apoc.coll.flatten(sdf_lists)),
            survival_filters:           apoc.coll.toSet(apoc.coll.flatten(svf_lists)),
            treatment_filters:          apoc.coll.toSet(apoc.coll.flatten(tf_lists)),
            treatment_response_filters: apoc.coll.toSet(apoc.coll.flatten(trf_lists))
          } ELSE {
            participant_id: null,
            race: null,
            sex_at_birth: null,
            sample_diagnosis_filters: apoc.coll.toSet(apoc.coll.flatten(sdf_lists)),
            survival_filters: [],
            treatment_filters: [],
            treatment_response_filters: []
          } END AS rowmap
          WITH file_uid, collect(distinct p.id) as pids, collect(distinct p.participant_id) as participant_ids, apoc.coll.toSet(apoc.coll.flatten(collect(distinct sids))) as sample_ids, collect(DISTINCT rowmap) AS combined_filters
          OPTIONAL MATCH (sm:sample)<--(file)
          where (file: generic_file OR file:pathology_file OR file:methylation_array_file OR file:cytogenomic_file) and file.dcf_indexd_guid = file_uid
          WITH file_uid, pids, participant_ids, [v IN sample_ids WHERE v IS NOT NULL] as sample_ids, combined_filters, head(collect(file)) AS file
          optional match (file)-[*..8]->(st:study)
          with file_uid, pids, participant_ids, [v IN sample_ids WHERE v IS NOT NULL] as sample_ids, combined_filters, file, st
          RETURN DISTINCT
            file_uid as id,
            pids as pid,
            file_uid AS file_id,
            file.dcf_indexd_guid AS guid,
            file.file_name AS file_name,
            file.file_access AS file_access,
            apoc.text.split(file.data_category, ';') As data_category,
            file.file_type AS file_type,
            file.file_mapping_level as file_mapping_level,
            file.file_description AS file_description,
            file.file_size AS file_size,
            file.md5sum AS md5sum,
            st.study_id AS study_id,
            st.dbgap_accession as dbgap_accession,
            st.study_status AS study_status,
            st.study_acronym as study_acronym,
            st.study_name as study_name,
            participant_ids AS participant_id,
            sample_ids AS sample_id,
            apoc.text.join(participant_ids, ',') as participant_id_gs,
            apoc.text.join(sample_ids, ',') as sample_id_gs,
            st.study_id as study_id_gs,
            file.file_description as file_description_gs,
            file.file_type as file_type_gs,
            file.file_name as file_name_gs,
            file.data_category as data_category_gs,
            [file_uid] as files,
            combined_filters as combined_filters,
            null AS library_selection,
            null AS library_source_material,
            null AS library_source_molecule,
            null AS library_strategy
        page_size: 1000 
      - query: |
         MATCH (st:study)<-[:of_consent_group]-(cg:consent_group)<-[:of_participant]-(p:participant)<--(sm1:sample)<-[*2..2]-(sm:sample)
          where not ((sm)<--(:sequencing_file)) and not ((sm)<--(:generic_file)) and not ((sm)<--(:cytogenomic_file)) and not ((sm)<--(:pathology_file)) and not ((sm)<--(:methylation_array_file)) and not ((p)<--(:radiology_file)) and not ((p)<--(:clinical_measure_file)) and not ((p)<--(:generic_file))
          OPTIONAL MATCH (p)<-[:of_diagnosis]-(dg:diagnosis)
          with p, sm1, sm, apoc.coll.union(case when collect(sm1) <> [] OR collect(dg) <> [] THEN COLLECT(DISTINCT {
                                sample_anatomic_site: apoc.text.split(sm1.anatomic_site, ';'),
                                participant_age_at_collection: sm1.participant_age_at_collection,
                                sample_tumor_status: sm1.sample_tumor_status,
                                tumor_classification: sm1.tumor_classification,
                                age_at_diagnosis: dg.age_at_diagnosis,
                                diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                                disease_phase: dg.disease_phase,
                                diagnosis_classification_system: dg.diagnosis_classification_system,  
                                diagnosis_basis: dg.diagnosis_basis,
                                tumor_grade_source: dg.tumor_grade_source,
                                tumor_stage_source: dg.tumor_stage_source,
                                diagnosis: dg.diagnosis,
                                diagnosis_category: apoc.text.split(dg.diagnosis_category, ';')
                            }) ELSE [] END, case when collect(sm) <> [] OR collect(dg) <> [] THEN COLLECT(DISTINCT {
                                sample_anatomic_site: apoc.text.split(sm.anatomic_site, ';'),
                                participant_age_at_collection: sm.participant_age_at_collection,
                                sample_tumor_status: sm.sample_tumor_status,
                                tumor_classification: sm.tumor_classification,
                                age_at_diagnosis: dg.age_at_diagnosis,
                                diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                                disease_phase: dg.disease_phase,
                                diagnosis_classification_system: dg.diagnosis_classification_system,
                                diagnosis_basis: dg.diagnosis_basis,
                                tumor_grade_source: dg.tumor_grade_source,
                                tumor_stage_source: dg.tumor_stage_source,
                                diagnosis: dg.diagnosis,
                                diagnosis_category: apoc.text.split(dg.diagnosis_category, ';')
                            }) ELSE [] END) as sample_diagnosis_filter_1
          MATCH (st:study)<-[:of_consent_group]-(cg:consent_group)<-[:of_participant]-(p)<--(sm1)<-[*2..2]-(sm)
          where not ((sm)<--(:sequencing_file)) and not ((sm)<--(:generic_file)) and not ((sm)<--(:cytogenomic_file)) and not ((sm)<--(:pathology_file)) and not ((sm)<--(:methylation_array_file)) and not ((p)<--(:radiology_file)) and not ((p)<--(:clinical_measure_file)) and not ((p)<--(:generic_file))
          OPTIONAL MATCH (sm1)<--(dg:diagnosis)
          with p, sm1, sm, sample_diagnosis_filter_1, apoc.coll.union(case when collect(sm1) <> [] OR collect(dg) <> [] THEN COLLECT(DISTINCT {
                                sample_anatomic_site: apoc.text.split(sm1.anatomic_site, ';'),
                                participant_age_at_collection: sm1.participant_age_at_collection,
                                sample_tumor_status: sm1.sample_tumor_status,
                                tumor_classification: sm1.tumor_classification,
                                age_at_diagnosis: dg.age_at_diagnosis,
                                diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                                disease_phase: dg.disease_phase,
                                diagnosis_classification_system: dg.diagnosis_classification_system,  
                                diagnosis_basis: dg.diagnosis_basis,
                                tumor_grade_source: dg.tumor_grade_source,
                                tumor_stage_source: dg.tumor_stage_source,
                                diagnosis: dg.diagnosis,
                                diagnosis_category: apoc.text.split(dg.diagnosis_category, ';')
                            }) ELSE [] END, case when collect(sm) <> [] OR collect(dg) <> [] THEN COLLECT(DISTINCT {
                                sample_anatomic_site: apoc.text.split(sm.anatomic_site, ';'),
                                participant_age_at_collection: sm.participant_age_at_collection,
                                sample_tumor_status: sm.sample_tumor_status,
                                tumor_classification: sm.tumor_classification,
                                age_at_diagnosis: dg.age_at_diagnosis,
                                diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                                disease_phase: dg.disease_phase,
                                diagnosis_classification_system: dg.diagnosis_classification_system,  
                                diagnosis_basis: dg.diagnosis_basis,
                                tumor_grade_source: dg.tumor_grade_source,
                                tumor_stage_source: dg.tumor_stage_source,
                                diagnosis: dg.diagnosis,
                                diagnosis_category: apoc.text.split(dg.diagnosis_category, ';')
                            }) ELSE [] END) AS sample_diagnosis_filter_2
          with p, sm1, sm, apoc.coll.union(sample_diagnosis_filter_1, sample_diagnosis_filter_2) as sample_diagnosis_filter_3
          MATCH (st:study)<-[:of_consent_group]-(cg:consent_group)<-[:of_participant]-(p)<--(sm1)<-[*2..2]-(sm)
          where not ((sm)<--(:sequencing_file)) and not ((sm)<--(:generic_file)) and not ((sm)<--(:cytogenomic_file)) and not ((sm)<--(:pathology_file)) and not ((sm)<--(:methylation_array_file)) and not ((p)<--(:radiology_file)) and not ((p)<--(:clinical_measure_file)) and not ((p)<--(:generic_file))
          OPTIONAL MATCH (sm)<--(dg:diagnosis)
          with p, sm1, sm, sample_diagnosis_filter_3, apoc.coll.union(case when collect(sm1) <> [] OR collect(dg) <> [] THEN COLLECT(DISTINCT {
                                sample_anatomic_site: apoc.text.split(sm1.anatomic_site, ';'),
                                participant_age_at_collection: sm1.participant_age_at_collection,
                                sample_tumor_status: sm1.sample_tumor_status,
                                tumor_classification: sm1.tumor_classification,
                                age_at_diagnosis: dg.age_at_diagnosis,
                                diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                                disease_phase: dg.disease_phase,
                                diagnosis_classification_system: dg.diagnosis_classification_system,
                                diagnosis_basis: dg.diagnosis_basis,
                                tumor_grade_source: dg.tumor_grade_source,
                                tumor_stage_source: dg.tumor_stage_source,
                                diagnosis: dg.diagnosis,
                                diagnosis_category: apoc.text.split(dg.diagnosis_category, ';')
                            }) ELSE [] END, case when collect(sm) <> [] OR collect(dg) <> [] THEN COLLECT(DISTINCT {
                                sample_anatomic_site: apoc.text.split(sm.anatomic_site, ';'),
                                participant_age_at_collection: sm.participant_age_at_collection,
                                sample_tumor_status: sm.sample_tumor_status,
                                tumor_classification: sm.tumor_classification,
                                age_at_diagnosis: dg.age_at_diagnosis,
                                diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                                disease_phase: dg.disease_phase,
                                diagnosis_classification_system: dg.diagnosis_classification_system,
                                diagnosis_basis: dg.diagnosis_basis,
                                tumor_grade_source: dg.tumor_grade_source,
                                tumor_stage_source: dg.tumor_stage_source,
                                diagnosis: dg.diagnosis,
                                diagnosis_category: apoc.text.split(dg.diagnosis_category, ';')
                            }) ELSE [] END) AS sample_diagnosis_filter_4
          with p, sm1, sm, apoc.coll.union(sample_diagnosis_filter_3, sample_diagnosis_filter_4) as sample_diagnosis_filter
          MATCH (st:study)<-[:of_consent_group]-(cg:consent_group)<-[:of_participant]-(p)<--(sm1)<-[*2..2]-(sm)
          OPTIONAL MATCH (p)<-[:of_survival]-(su:survival)
          OPTIONAL MATCH (p)<-[:of_treatment]-(tm:treatment)
          OPTIONAL MATCH (p)<-[:of_treatment_response]-(tr:treatment_response)
          with distinct p, sm1, sm, st, sample_diagnosis_filter, 
            case when collect(su) <> [] THEN COLLECT(DISTINCT {last_known_survival_status: su.last_known_survival_status, 
              event_free_survival_status: su.event_free_survival_status, 
              first_event: su.first_event,
              age_at_last_known_survival_status: su.age_at_last_known_survival_status} ) ELSE [] END as survival_filters,
            case when collect(tm) <> [] THEN COLLECT(DISTINCT{treatment_type: apoc.text.split(tm.treatment_type, ';'),
            treatment_agent: apoc.text.split(tm.treatment_agent, ';'),
            age_at_treatment_start: tm.age_at_treatment_start}) ELSE [] END as treatment_filters,
            case when collect(tr) <> [] THEN COLLECT(DISTINCT{response_category: tr.response_category,
            age_at_response: tr.age_at_response}) ELSE [] END as treatment_response_filters
          RETURN DISTINCT
            null as id,
            [p.id] as pid,
            null AS file_id,
            null AS guid,
            null AS file_name,
            null AS file_access,
            null AS data_category,
            null AS file_type,
            null AS file_mapping_level,
            null AS file_description,
            null AS file_size,
            null AS md5sum,
            st.study_id AS study_id,
            st.dbgap_accession as dbgap_accession,
            st.study_status AS study_status,
            st.study_acronym as study_acronym,
            st.study_name as study_name,
            p.participant_id AS participant_id,
            [sm1.sample_id, sm.sample_id] AS sample_id,
            p.participant_id as participant_id_gs,
            apoc.text.join([sm1.sample_id, sm.sample_id], ',') as sample_id_gs,
            st.study_id as study_id_gs,
            null as file_description_gs,
            null as file_type_gs,
            null as file_name_gs,
            null as data_category_gs,
            null as files,
            [{
              participant_id: p.participant_id,
              race: apoc.text.split(p.race, ';'),
              sex_at_birth: p.sex_at_birth,
              sample_diagnosis_filters: sample_diagnosis_filter,
              survival_filters: survival_filters,
              treatment_filters: treatment_filters,
              treatment_response_filters: treatment_response_filters
            }] as combined_filters,
            null AS library_selection,
            null AS library_source_material,
            null AS library_source_molecule,
            null AS library_strategy
      - query: |
          MATCH (st:study)<-[:of_consent_group]-(cg:consent_group)<-[:of_participant]-(p:participant)<--(sm:sample)
          where not ((sm)<-[*..3]-(:sequencing_file)) and not ((sm)<-[*..3]-(:generic_file)) and not ((sm)<-[*..3]-(:cytogenomic_file)) and not ((sm)<-[*..3]-(:pathology_file)) and not ((sm)<-[*..3]-(:methylation_array_file)) and not ((p)<--(:radiology_file)) and not ((p)<--(:clinical_measure_file)) and not ((p)<--(:generic_file))
          OPTIONAL MATCH (p)<-[*..2]-(dg:diagnosis)
          OPTIONAL MATCH (p)<-[:of_survival]-(su:survival)
          OPTIONAL MATCH (p)<-[:of_treatment]-(tm:treatment)
          OPTIONAL MATCH (p)<-[:of_treatment_response]-(tr:treatment_response)
          with distinct p, st, collect(distinct sm.sample_id) as sample_ids, case when collect(sm) <> [] OR collect(dg) <> [] THEN COLLECT(DISTINCT {
                sample_anatomic_site: apoc.text.split(sm.anatomic_site, ';'),
                participant_age_at_collection: sm.participant_age_at_collection,
                sample_tumor_status: sm.sample_tumor_status,
                tumor_classification: sm.tumor_classification,
                age_at_diagnosis: dg.age_at_diagnosis,
                diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                disease_phase: dg.disease_phase,
                diagnosis_classification_system: dg.diagnosis_classification_system,
                diagnosis_basis: dg.diagnosis_basis,
                tumor_grade_source: dg.tumor_grade_source,
                tumor_stage_source: dg.tumor_stage_source,
                diagnosis: dg.diagnosis,
                diagnosis_category: apoc.text.split(dg.diagnosis_category, ';')
            }) ELSE [] END as sample_diagnosis_filter,
            case when collect(su) <> [] THEN COLLECT(DISTINCT {last_known_survival_status: su.last_known_survival_status, 
              event_free_survival_status: su.event_free_survival_status, 
              first_event: su.first_event,
              age_at_last_known_survival_status: su.age_at_last_known_survival_status} ) ELSE [] END as survival_filters,
            case when collect(tm) <> [] THEN COLLECT(DISTINCT{treatment_type: apoc.text.split(tm.treatment_type, ';'),
            treatment_agent: apoc.text.split(tm.treatment_agent, ';'),
            age_at_treatment_start: tm.age_at_treatment_start}) ELSE [] END as treatment_filters,
            case when collect(tr) <> [] THEN COLLECT(DISTINCT{response_category: tr.response_category,
            age_at_response: tr.age_at_response}) ELSE [] END as treatment_response_filters
          RETURN DISTINCT
            null as id,
            [p.id] as pid,
            null AS file_id,
            null AS guid,
            null AS file_name,
            null AS file_access,
            null AS data_category,
            null AS file_type,
            null AS file_mapping_level,
            null AS file_description,
            null AS file_size,
            null AS md5sum,
            st.study_id AS study_id,
            st.dbgap_accession as dbgap_accession,
            st.study_status AS study_status,
            st.study_acronym as study_acronym,
            st.study_name as study_name,
            p.participant_id AS participant_id,
            sample_ids AS sample_id,
            p.participant_id as participant_id_gs,
            apoc.text.join(sample_ids, ',') as sample_id_gs,
            st.study_id as study_id_gs,
            null as file_description_gs,
            null as file_type_gs,
            null as file_name_gs,
            null as data_category_gs,
            null as files,
            [{
              participant_id: p.participant_id,
              race: apoc.text.split(p.race, ';'),
              sex_at_birth: p.sex_at_birth,
              sample_diagnosis_filters: sample_diagnosis_filter,
              survival_filters: survival_filters,
              treatment_filters: treatment_filters,
              treatment_response_filters: treatment_response_filters
            }] as combined_filters,
            null AS library_selection,
            null AS library_source_material,
            null AS library_source_molecule,
            null AS library_strategy
      - query: |
          MATCH (st:study)<--(cl)<--(sm:sample)
          Where (cl: cell_line or cl: pdx) and not ((sm)<--(:sequencing_file)) and not ((sm)<--(:generic_file)) and not ((sm)<--(:cytogenomic_file)) and not ((sm)<--(:pathology_file)) and not ((sm)<--(:methylation_array_file))
          optional match (sm)<--(dg:diagnosis)
          with sm, dg, st
          with sm, st, case when collect(sm) <> [] OR collect(dg) <> [] THEN COLLECT(DISTINCT {
                sample_anatomic_site: apoc.text.split(sm.anatomic_site, ';'),
                participant_age_at_collection: sm.participant_age_at_collection,
                sample_tumor_status: sm.sample_tumor_status,
                tumor_classification: sm.tumor_classification,
                age_at_diagnosis: null,
                diagnosis_anatomic_site: null,
                disease_phase: null,
                diagnosis_classification_system: null,
                diagnosis_category: null,
                diagnosis_basis: null,
                tumor_grade_source: null,
                tumor_stage_source: null,
                diagnosis_classification: null
            }) ELSE [] END as sample_diagnosis_filter
          RETURN DISTINCT
            null as id,
            [] as pid,
            null AS file_id,
            null AS guid,
            null AS file_name,
            null AS file_access,
            null AS data_category,
            null AS file_type,
            null AS file_mapping_level,
            null AS file_description,
            null AS file_size,
            null AS md5sum,
            st.study_id AS study_id,
            st.dbgap_accession as dbgap_accession,
            st.study_status AS study_status,
            st.study_acronym as study_acronym,
            st.study_name as study_name,
            null AS participant_id,
            sm.sample_id AS sample_id,
            null as participant_id_gs,
            sm.sample_id as sample_id_gs,
            st.study_id as study_id_gs,
            null as file_description_gs,
            null as file_type_gs,
            null as file_name_gs,
            null as data_category_gs,
            null as files,
            [{
              participant_id: null,
              race: null,
              sex_at_birth: null,
              sample_diagnosis_filters: sample_diagnosis_filter,
              survival_filters: [],
              treatment_filters: [],
              treatment_response_filters: []
            }] as combined_filters,
            null AS library_selection,
            null AS library_source_material,
            null AS library_source_molecule,
            null AS library_strategy
      - query: |
          MATCH (st:study)<-[:of_consent_group]-(cg:consent_group)<-[:of_participant]-(p:participant)
          where not ((p)<--(:sample)) and not ((p)<--(:radiology_file)) and not ((p)<--(:clinical_measure_file)) and not ((p)<--(:generic_file))
          OPTIONAL MATCH (p)<-[:of_diagnosis]-(dg:diagnosis)
          OPTIONAL MATCH (p)<-[:of_survival]-(su:survival)
          OPTIONAL MATCH (p)<-[:of_treatment]-(tm:treatment)
          OPTIONAL MATCH (p)<-[:of_treatment_response]-(tr:treatment_response)
          with distinct p, st, case when collect(dg) <> [] THEN COLLECT(DISTINCT {
                sample_anatomic_site: null,
                participant_age_at_collection: null,
                sample_tumor_status: null,
                tumor_classification: null,
                age_at_diagnosis: dg.age_at_diagnosis,
                diagnosis_anatomic_site: apoc.text.split(dg.anatomic_site, ';'),
                disease_phase: dg.disease_phase,
                diagnosis_classification_system: dg.diagnosis_classification_system,
                diagnosis_category: apoc.text.split(dg.diagnosis_category, ';'),
                diagnosis_basis: dg.diagnosis_basis,
                tumor_grade_source: dg.tumor_grade_source,
                tumor_stage_source: dg.tumor_stage_source,
                diagnosis_classification: dg.diagnosis_classification
            }) ELSE [] END as sample_diagnosis_filter, 
            case when collect(su) <> [] THEN COLLECT(DISTINCT {last_known_survival_status: su.last_known_survival_status, 
              event_free_survival_status: su.event_free_survival_status, 
              first_event: su.first_event,
              age_at_last_known_survival_status: su.age_at_last_known_survival_status} ) ELSE [] END as survival_filters,
            case when collect(tm) <> [] THEN COLLECT(DISTINCT{treatment_type: apoc.text.split(tm.treatment_type, ';'),
            treatment_agent: apoc.text.split(tm.treatment_agent, ';'),
            age_at_treatment_start: tm.age_at_treatment_start}) ELSE [] END as treatment_filters,
            case when collect(tr) <> [] THEN COLLECT(DISTINCT{response_category: tr.response_category,
            age_at_response: tr.age_at_response}) ELSE [] END as treatment_response_filters          
          RETURN DISTINCT
            null as id,
            [] as pid,
            null AS file_id,
            null AS guid,
            null AS file_name,
            null AS file_access,
            null AS data_category,
            null AS file_type,
            null AS file_mapping_level,
            null AS file_description,
            null AS file_size,
            null AS md5sum,
            st.study_id AS study_id,
            st.dbgap_accession as dbgap_accession,
            st.study_status AS study_status,
            st.study_acronym as study_acronym,
            st.study_name as study_name,
            p.participant_id AS participant_id,
            null AS sample_id,
            p.participant_id as participant_id_gs,
            null as sample_id_gs,
            st.study_id as study_id_gs,
            null as file_description_gs,
            null as file_type_gs,
            null as file_name_gs,
            null as data_category_gs,
            null as files,
            [{
              participant_id: p.participant_id,
              race: apoc.text.split(p.race, ';'),
              sex_at_birth: p.sex_at_birth,
              sample_diagnosis_filters: sample_diagnosis_filter,
              survival_filters: survival_filters,
              treatment_filters: treatment_filters,
              treatment_response_filters: treatment_response_filters
            }] as combined_filters,
            null AS library_selection,
            null AS library_source_material,
            null AS library_source_molecule,
            null AS library_strategy

  - index_name: model_nodes
    type: model
    subtype: node
    # type mapping for each property of the index
    mapping:
      node:
        type: search_as_you_type
      node_kw:
        type: keyword
  # Model properties index
  - index_name: model_properties
    type: model
    subtype: property
    # type mapping for each property of the index
    mapping:
      node:
        type: search_as_you_type
      property:
        type: search_as_you_type
      property_kw:
        type: keyword
      property_description:
        type: search_as_you_type
      property_required:
        type: search_as_you_type
      property_type:
        type: search_as_you_type
  # Model values index
  - index_name: model_values
    type: model
    subtype: value
    # type mapping for each property of the index
    mapping:
      node:
        type: search_as_you_type
      property:
        type: search_as_you_type
      property_description:
        type: search_as_you_type
      property_required:
        type: search_as_you_type
      property_type:
        type: search_as_you_type
      value:
        type: search_as_you_type
      value_kw:
        type: keyword
  - index_name: idc_tcia
    type: external
    # type mapping for each property of the index
    mapping:
      timestamp:
        type: date
      source:
        type: keyword
      data:
        type: object